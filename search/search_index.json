{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quant on Crypto","text":""},{"location":"design/","title":"System Design","text":""},{"location":"design/#overview","title":"Overview","text":"<p>This document outlines the architecture for a quantitative trading system for cryptocurrency markets. The system supports both backtesting and live trading with a modular feature-based approach.</p>"},{"location":"design/#core-components","title":"Core Components","text":""},{"location":"design/#state-management","title":"State Management","text":"<pre><code>class State:\n    raw: ...\n    trade: ...\n    features: ...\n</code></pre> <p>The <code>State</code> class maintains the current system state including:</p> <ul> <li>raw: Market data and historical information</li> <li>trade: Current trading positions</li> <li>features: Computed technical indicators and features</li> </ul>"},{"location":"design/#feature-system","title":"Feature System","text":""},{"location":"design/#base-feature-interface","title":"Base Feature Interface","text":"<pre><code>class Feature:\n    def compute(self, state: State) -&gt; State: ...\n</code></pre> <p>All features inherit from <code>Feature</code> and implement the <code>compute</code> method to compute indicators from timeline data.</p>"},{"location":"design/#feature-implementations","title":"Feature Implementations","text":"<pre><code>class Feature1(Feature):\n    window: int = 100\n\n    def compute(self, state: State) -&gt; State: ...\n\nclass Feature2(Feature):\n    param: float = 1.0\n\n    def compute(self, state: State) -&gt; State: ...\n</code></pre> <p>Features are configurable with parameters:</p> <ul> <li>Feature1: Window-based indicator (e.g., moving average)</li> <li>Feature2: Parameter-driven indicator</li> </ul>"},{"location":"design/#feature-store","title":"Feature Store","text":"<pre><code>class FeatureStore:\n    def compute(self, state: State) -&gt; State: ...\n\nfeatures = FeatureStore(features=[Feature1(window=100), Feature2(param=1.0)])\n</code></pre> <p>The <code>FeatureStore</code> manages feature computation and updates the system state with calculated indicators.</p>"},{"location":"design/#trading-strategy","title":"Trading Strategy","text":"<pre><code>class Strategy:\n    stats: Statistics\n    timeline: Timeline\n\n    def needs_update(self, timestamp: Timestamp) -&gt; bool: ...\n    def gen_signal(self): ...\n</code></pre> <p>The <code>Strategy</code> class:</p> <ul> <li>Determines when updates are needed</li> <li>Generates trading signals based on computed features</li> <li>Maintains statistics and timeline data</li> </ul>"},{"location":"design/#trading-systems","title":"Trading Systems","text":""},{"location":"design/#trade-system-interface","title":"Trade System Interface","text":"<pre><code>class TradeSystemAPI:\n    def place_order(self, coin: CoinName, amount: float, price: float) -&gt; None: ...\n    def cancel_order(self, coin: CoinName) -&gt; None: ...\n    def query_order(self, coin: CoinName) -&gt; OrderStatus: ...\n</code></pre>"},{"location":"design/#implementations","title":"Implementations","text":"<ul> <li>LocalTradeSystem: For backtesting and simulation</li> <li>BinanceTradeSystem: For live trading on Binance exchange</li> </ul>"},{"location":"design/#system-workflows","title":"System Workflows","text":""},{"location":"design/#main-trading-loop","title":"Main Trading Loop","text":"<pre><code>def main() -&gt; None:\n    timeline = Timeline()\n    stats = Statistics(\n        timeline=timeline,\n        feature_configs=[Feature1(window=100), Feature2(param=1.0)]\n    )\n    strategy = Strategy(stats=stats, timeline=timeline)\n</code></pre>"},{"location":"design/#backtesting-workflow","title":"Backtesting Workflow","text":"<pre><code>def backtest():\n    # Initialize timelines\n    raw_timeline = Timeline()\n    trade_timeline = Timeline()\n    strategy_timeline = Timeline()\n\n    # Setup strategy and trade system\n    strategy = Strategy(\n        stats=Statistics(\n            timeline=strategy_timeline,\n            feature_configs=[Feature1(window=100), Feature2(param=1.0)],\n        )\n    )\n    trade = TradeSystem(timeline=trade_timeline, strategy=strategy)\n\n    # Main backtesting loop\n    for timestamp in timestamps:\n        # 1. Update raw market data\n        # 2. Update trade system data\n        # 3. Update strategy data (features, positions, capital)\n        # 4. Generate and apply trading signals\n\n        trade.update(raw_data.latest)\n        strategy.time_pass(trade.latest)\n        strategy.stats.feature_calc()\n        signals = strategy.gen_signal()\n\n        # Execute trades based on signals\n        for coin, signal in signals.items():\n            trade.trade(coin, signal)\n</code></pre>"},{"location":"design/#data-flow","title":"Data Flow","text":"<ol> <li>Raw Data Ingestion: Market data flows into the raw timeline</li> <li>Trade Data Update: Trading system processes and updates trade timeline</li> <li>Feature Computation: Features are calculated from available data</li> <li>Signal Generation: Strategy generates trading signals based on features</li> <li>Trade Execution: Signals are executed through the trading system API</li> </ol>"},{"location":"reference/qoc/","title":"qoc","text":""},{"location":"reference/qoc/#qoc","title":"qoc","text":"<p>Modules:</p> <ul> <li> <code>api</code>           \u2013            </li> <li> <code>balance</code>           \u2013            </li> <li> <code>database</code>           \u2013            </li> <li> <code>feature</code>           \u2013            </li> <li> <code>market</code>           \u2013            </li> <li> <code>strategy</code>           \u2013            </li> <li> <code>struct</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul> <p>Type Aliases:</p> <ul> <li> <code>Interval</code>           \u2013            </li> <li> <code>SnapLike</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>ApiBinance</code>           \u2013            </li> <li> <code>ApiOffline</code>           \u2013            </li> <li> <code>Balance</code>           \u2013            </li> <li> <code>CaseInsensitiveEnum</code>           \u2013            </li> <li> <code>Database</code>           \u2013            </li> <li> <code>Library</code>           \u2013            </li> <li> <code>Market</code>           \u2013            </li> <li> <code>Snap</code>           \u2013            </li> <li> <code>Strategy</code>           \u2013            </li> <li> <code>StrategySingleSymbol</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>clock</code>             \u2013              </li> <li> <code>data_dir</code>             \u2013              </li> <li> <code>entrypoint</code>             \u2013              </li> <li> <code>fig_dir</code>             \u2013              </li> <li> <code>insert_time</code>             \u2013              </li> <li> <code>working_dir</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>__version__</code>               (<code>str</code>)           \u2013            </li> <li> <code>__version_tuple__</code>               (<code>tuple[int | str, ...]</code>)           \u2013            </li> <li> <code>version</code>               (<code>str</code>)           \u2013            </li> <li> <code>version_tuple</code>               (<code>tuple[int | str, ...]</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/#qoc.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__: str = '0.1.dev17+g8c44c5df6'\n</code></pre>"},{"location":"reference/qoc/#qoc.__version_tuple__","title":"__version_tuple__  <code>module-attribute</code>","text":"<pre><code>__version_tuple__: tuple[int | str, ...] = (\n    0,\n    1,\n    \"dev17\",\n    \"g8c44c5df6\",\n)\n</code></pre>"},{"location":"reference/qoc/#qoc.version","title":"version  <code>module-attribute</code>","text":"<pre><code>version: str = '0.1.dev17+g8c44c5df6'\n</code></pre>"},{"location":"reference/qoc/#qoc.version_tuple","title":"version_tuple  <code>module-attribute</code>","text":"<pre><code>version_tuple: tuple[int | str, ...] = (\n    0,\n    1,\n    \"dev17\",\n    \"g8c44c5df6\",\n)\n</code></pre>"},{"location":"reference/qoc/#qoc.Interval","title":"Interval","text":"<pre><code>Interval = Literal[\n    \"1s\",\n    \"1m\",\n    \"3m\",\n    \"5m\",\n    \"15m\",\n    \"30m\",\n    \"1h\",\n    \"2h\",\n    \"4h\",\n    \"6h\",\n    \"8h\",\n    \"12h\",\n    \"1d\",\n    \"3d\",\n    \"1w\",\n    \"1M\",\n]\n</code></pre>"},{"location":"reference/qoc/#qoc.SnapLike","title":"SnapLike","text":"<pre><code>SnapLike = Snap | Literal['none', 'second']\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiBinance","title":"ApiBinance","text":"<p>Parameters:</p> <ul> <li> <code>client</code>               (<code>Spot</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>account</code>             \u2013              </li> <li> <code>create</code>             \u2013              </li> <li> <code>exchange_info</code>             \u2013              </li> <li> <code>klines</code>             \u2013              </li> <li> <code>order</code>             \u2013              </li> <li> <code>order_market</code>             \u2013              </li> <li> <code>ping</code>             \u2013              </li> <li> <code>step</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>client</code>               (<code>Spot</code>)           \u2013            </li> <li> <code>timeunit</code>               (<code>TimeUnit</code>)           \u2013            <p>.</p> </li> </ul>"},{"location":"reference/qoc/#qoc.ApiBinance.client","title":"client  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client: Spot = field()\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiBinance.timeunit","title":"timeunit  <code>property</code>","text":"<pre><code>timeunit: TimeUnit\n</code></pre> <p>.</p> <p>All time and timestamp related fields in the JSON responses are in milliseconds by default.</p> References <ol> <li>https://developers.binance.com/docs/binance-spot-api-docs/testnet/rest-api/general-api-information</li> </ol>"},{"location":"reference/qoc/#qoc.ApiBinance.account","title":"account","text":"<pre><code>account(**kwargs) -&gt; Account\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def account(self, **kwargs) -&gt; Account:\n    raw: dict = self.client.account(**kwargs)\n    return Account.model_validate(raw)\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiBinance.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    api_key: str | None = None,\n    api_secret: str | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>@classmethod\ndef create(\n    cls, api_key: str | None = None, api_secret: str | None = None, **kwargs\n) -&gt; Self:\n    if api_key is None:\n        api_key = env.str(\"BINANCE_API_KEY\", None)\n    if api_secret is None:\n        api_secret = env.str(\"BINANCE_API_SECRET\", None)\n    if not kwargs.get(\"base_url\") and (\n        base_url := env.str(\"BINANCE_BASE_URL\", None)\n    ):\n        kwargs[\"base_url\"] = base_url\n    client = binance.spot.Spot(api_key=api_key, api_secret=api_secret, **kwargs)\n    return cls(client=client)\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiBinance.exchange_info","title":"exchange_info","text":"<pre><code>exchange_info(\n    symbol: str | None = None,\n    symbols: list[str] | None = None,\n    permissions: list[str] | None = None,\n) -&gt; ExchangeInfo\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def exchange_info(\n    self,\n    symbol: str | None = None,\n    symbols: list[str] | None = None,\n    permissions: list[str] | None = None,\n) -&gt; ExchangeInfo:\n    data = self.client.exchange_info(\n        symbol=symbol,  # pyright: ignore[reportArgumentType]\n        symbols=symbols,  # pyright: ignore[reportArgumentType]\n        permissions=permissions,  # pyright: ignore[reportArgumentType]\n    )\n    return ExchangeInfo.model_validate(data)\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiBinance.klines","title":"klines","text":"<pre><code>klines(\n    symbol: str,\n    interval: Interval,\n    *,\n    start_time: datetime | None = None,\n    **kwargs,\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def klines(\n    self,\n    symbol: str,\n    interval: Interval,\n    *,\n    start_time: datetime.datetime | None = None,\n    **kwargs,\n) -&gt; pl.DataFrame:\n    if start_time:\n        kwargs[\"startTime\"] = self.timeunit.from_datetime(start_time)\n    response: list[list[int | str]] = self.client.klines(\n        symbol=symbol, interval=interval, **kwargs\n    )\n    data: pl.DataFrame = pl.from_records(\n        response,\n        schema=[\n            (\n                \"open_time\",\n                pl.Datetime(time_unit=self.timeunit.to_polars),\n            ),  # Kline open time\n            (\"open\", pl.Float64),  # Open price\n            (\"high\", pl.Float64),  # High price\n            (\"low\", pl.Float64),  # Low price\n            (\"close\", pl.Float64),  # Close price\n            (\"volume\", pl.Float64),  # Volume\n            (\n                \"close_time\",\n                pl.Datetime(time_unit=self.timeunit.to_polars),\n            ),  # Kline Close time\n            (\"quote_volume\", pl.Float64),  # Quote asset volume\n            (\"count\", pl.Int64),  # Number of trades\n            (\"taker_buy_volume\", pl.Float64),  # Taker buy base asset volume\n            (\"taker_buy_quote_volume\", pl.Float64),  # Taker buy quote asset volume\n            (\"ignore\", pl.Int64),  # Unused field, ignore.\n        ],\n        orient=\"row\",\n    )\n\n\n    # \u5c06 Datetime \u65f6\u95f4\u6233\u8f6c\u6362\u4e3a\u6574\u6570\u5fae\u79d2\u65f6\u95f4\u6233\n    time_unit_multiplier = {\n        \"ns\": 0.001,  # \u7eb3\u79d2\u8f6c\u5fae\u79d2\u9700\u8981\u9664\u4ee5 1000\n        \"us\": 1,      # \u5fae\u79d2\u4fdd\u6301\u4e0d\u53d8\n        \"ms\": 1000,   # \u6beb\u79d2\u8f6c\u5fae\u79d2\u9700\u8981\u4e58\u4ee5 1000\n        \"s\": 1000000, # \u79d2\u8f6c\u5fae\u79d2\u9700\u8981\u4e58\u4ee5 1000000\n    }[self.timeunit.to_polars]\n\n    # \u8f6c\u6362\u65f6\u95f4\u5217\u4e3a\u6574\u6570\u5fae\u79d2\u65f6\u95f4\u6233\n    data = data.with_columns([\n        pl.col(\"open_time\").dt.epoch(\"us\").alias(\"open_time\"),\n        pl.col(\"close_time\").dt.epoch(\"us\").alias(\"close_time\")\n    ])\n    return data\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiBinance.order","title":"order","text":"<pre><code>order(\n    symbol: str,\n    side: OrderSideLike,\n    type_: OrderTypeLike,\n    **kwargs,\n) -&gt; OrderResponseFull\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def order(\n    self, symbol: str, side: OrderSideLike, type_: OrderTypeLike, **kwargs\n) -&gt; OrderResponseFull:\n    side = OrderSide(side)\n    type_ = OrderType(type_)\n    logger.info(\n        \"New Order &gt; symbol: {}, side: {}, type: {}, {}\",\n        symbol,\n        side,\n        type_,\n        kwargs,\n    )\n    raw: dict = self.client.new_order(\n        symbol=symbol, side=side, type=type_, **kwargs\n    )\n    response: OrderResponseFull = OrderResponseFull.model_validate(raw)\n    logger.info(response)\n    return response\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiBinance.order_market","title":"order_market","text":"<pre><code>order_market(\n    symbol: str,\n    side: OrderSideLike,\n    *,\n    quantity: float | None = None,\n    quoteOrderQty: float | None = None,\n    **kwargs,\n) -&gt; OrderResponseFull\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def order_market(\n    self,\n    symbol: str,\n    side: OrderSideLike,\n    *,\n    quantity: float | None = None,\n    quoteOrderQty: float | None = None,\n    **kwargs,\n) -&gt; OrderResponseFull:\n    if quantity is not None:\n        kwargs[\"quantity\"] = f\"{quantity:f}\"\n    if quoteOrderQty is not None:\n        kwargs[\"quoteOrderQty\"] = f\"{quoteOrderQty:f}\"\n    return self.order(symbol, side, OrderType.MARKET, **kwargs)\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiBinance.ping","title":"ping","text":"<pre><code>ping() -&gt; None\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def ping(self) -&gt; None:\n    self.client.ping()\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiBinance.step","title":"step","text":"<pre><code>step() -&gt; bool\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def step(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiOffline","title":"ApiOffline","text":"<p>               Bases: <code>TradingApi</code></p> <p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>monitor_account</code>               (<code>dict</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> <li> <code>timestamps</code>               (<code>list[int]</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> </li> <li> <code>now_index</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            </li> <li> <code>interval</code>               (<code>int</code>, default:                   <code>60000000</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>account</code>             \u2013              <p>\u8fd4\u56de\u5f53\u524d\u6a21\u62df\u8d26\u6237\u4fe1\u606f</p> </li> <li> <code>create</code>             \u2013              </li> <li> <code>exchange_info</code>             \u2013              </li> <li> <code>klines</code>             \u2013              </li> <li> <code>order_market</code>             \u2013              </li> <li> <code>step</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>interval</code>               (<code>int</code>)           \u2013            </li> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>monitor_account</code>               (<code>dict</code>)           \u2013            </li> <li> <code>now_index</code>               (<code>int</code>)           \u2013            </li> <li> <code>timestamps</code>               (<code>list[int]</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/#qoc.ApiOffline.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interval: int = field(default=60 * 1000000)\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiOffline.library","title":"library  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library: Library = field()\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiOffline.monitor_account","title":"monitor_account  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>monitor_account: dict = field(factory=dict)\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiOffline.now_index","title":"now_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>now_index: int = field(default=0)\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiOffline.timestamps","title":"timestamps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestamps: list[int] = field(factory=list)\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiOffline.account","title":"account","text":"<pre><code>account(**kwargs) -&gt; Account\n</code></pre> <p>\u8fd4\u56de\u5f53\u524d\u6a21\u62df\u8d26\u6237\u4fe1\u606f</p> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>@override\ndef account(self, **kwargs) -&gt; Account:\n    \"\"\"\u8fd4\u56de\u5f53\u524d\u6a21\u62df\u8d26\u6237\u4fe1\u606f\"\"\"\n    # \u76f4\u63a5\u4f7f\u7528\u5b58\u50a8\u7684\u8d26\u6237\u6570\u636e\u7ed3\u6784\n    from qoc.api.typing import Account\n\n    # \u8fd4\u56de\u9a8c\u8bc1\u8fc7\u7684\u8d26\u6237\u5bf9\u8c61\n    return Account.model_validate(self.monitor_account)\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiOffline.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    library: Library,\n    symbols: list[str],\n    start_date: str,\n    end_date: str,\n) -&gt; Self\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>@classmethod\ndef create(cls, library: adb.library.Library, symbols: list[str], start_date: str, end_date: str) -&gt; Self:\n    from datetime import datetime, timedelta\n    import pandas as pd\n\n    # \u8f6c\u6362\u65e5\u671f\u5b57\u7b26\u4e32\u4e3adatetime\u5bf9\u8c61\n    start_dt = datetime.strptime(start_date, \"%Y-%m-%d\")\n    end_dt = datetime.strptime(end_date, \"%Y-%m-%d\")\n\n    # \u521d\u59cb\u5316\u65f6\u95f4\u6233\u5217\u8868\n    timestamps = []\n\n    # \u9ed8\u8ba4\u4f7f\u75281\u5206\u949f\u95f4\u9694\n    interval = \"1m\"\n\n    # \u5b9a\u4e49\u9884\u671f\u7684\u95f4\u9694\uff08\u5fae\u79d2\uff09\n    expected_interval_micros = 60 * 1000000  # 1\u5206\u949f = 60\u79d2 = 60,000,000\u5fae\u79d2\n\n    # \u8f6c\u6362\u65e5\u671f\u8303\u56f4\u4e3a\u65f6\u95f4\u6233\uff08\u5fae\u79d2\uff09\n    start_timestamp = int(start_dt.timestamp() * 1000000)\n    end_timestamp = int(end_dt.timestamp() * 1000000)\n\n    # \u4ece\u6240\u6709\u4ea4\u6613\u5bf9\u4e2d\u6536\u96c6\u65f6\u95f4\u6233\n    all_timestamps = set()\n\n    for symbol in symbols:\n        symbol_key = f\"{symbol}_klines_{interval}\"\n\n        if symbol_key in library.list_symbols():\n            try:\n                # \u8bfb\u53d6\u6570\u636e\n                result = library.read(symbol_key).data\n\n                df_pandas: pd.DataFrame = result \n\n                # \u68c0\u67e5\u6570\u636e\u662f\u5426\u4e3a\u7a7a\n                if not df_pandas.empty:\n                    # \u83b7\u53d6\u5217\u548c\u7d22\u5f15\u4fe1\u606f\n                    columns = df_pandas.columns.tolist()\n\n                    # \u60c5\u51b51: \"Close Time\" \u4f5c\u4e3a\u666e\u901a\u5217\n                    if \"Close Time\" in columns:\n                        all_timestamps.update(\n                            ts for ts in df_pandas[\"Close Time\"] \n                            if start_timestamp &lt;= ts &lt;= end_timestamp\n                        )\n                    # \u60c5\u51b52: \u7d22\u5f15\u53ef\u80fd\u662f\u65f6\u95f4\u6233\uff08\u68c0\u67e5\u7d22\u5f15\u540d\u79f0\u6216\u7c7b\u578b\uff09\n                    elif df_pandas.index.name == \"Close Time\" or isinstance(df_pandas.index, pd.DatetimeIndex):\n                        # \u5982\u679c\u7d22\u5f15\u662fDatetimeIndex\uff0c\u9700\u8981\u8f6c\u6362\u4e3a\u5fae\u79d2\u65f6\u95f4\u6233\n                        if isinstance(df_pandas.index, pd.DatetimeIndex):\n                            index_timestamps = (df_pandas.index.astype(int) // 1000).tolist()  # \u7eb3\u79d2\u8f6c\u5fae\u79d2\n                        else:\n                            index_timestamps = df_pandas.index.tolist()\n\n                        all_timestamps.update(\n                            ts for ts in index_timestamps\n                            if start_timestamp &lt;= ts &lt;= end_timestamp\n                        )\n                    else:\n                        print(f\"\u8b66\u544a: {symbol_key} \u4e2d\u6ca1\u6709\u627e\u5230 'Close Time' \u5217\u6216\u65f6\u95f4\u7d22\u5f15\")\n\n            except Exception as e:\n                print(f\"\u5904\u7406\u4ea4\u6613\u5bf9 {symbol} \u65f6\u51fa\u9519: {e}\")\n\n    # \u5c06\u96c6\u5408\u8f6c\u6362\u4e3a\u5217\u8868\u5e76\u6392\u5e8f\n    timestamps = sorted(all_timestamps)\n\n    # \u68c0\u67e5\u65f6\u95f4\u6233\u95f4\u9694\n    if len(timestamps) &gt; 1:\n        # \u8ba1\u7b97\u6240\u6709\u76f8\u90bb\u65f6\u95f4\u6233\u4e4b\u95f4\u7684\u95f4\u9694\n        intervals = [timestamps[i+1] - timestamps[i] for i in range(len(timestamps)-1)]\n\n        # \u7edf\u8ba1\u5206\u6790\n        min_interval = min(intervals)\n        max_interval = max(intervals)\n        avg_interval = sum(intervals) / len(intervals)\n\n        print(f\"\u65f6\u95f4\u6233\u95f4\u9694\u7edf\u8ba1:\")\n        print(f\"  \u6700\u5c0f\u95f4\u9694: {min_interval} \u5fae\u79d2 ({min_interval/1000000} \u79d2)\")\n        print(f\"  \u6700\u5927\u95f4\u9694: {max_interval} \u5fae\u79d2 ({max_interval/1000000} \u79d2)\")\n        print(f\"  \u5e73\u5747\u95f4\u9694: {avg_interval} \u5fae\u79d2 ({avg_interval/1000000} \u79d2)\")\n\n        # \u68c0\u67e5\u662f\u5426\u6240\u6709\u95f4\u9694\u90fd\u7b26\u5408\u9884\u671f\n        one_minute_micros = 60 * 1000000  # 1\u5206\u949f\u7684\u5fae\u79d2\u6570\n        tolerance = 0  # \u5141\u8bb80\u8bef\u5dee\n\n        all_one_minute = all(abs(interval - one_minute_micros) &lt;= tolerance for interval in intervals)\n\n        if all_one_minute:\n            print(f\"\u2713 \u6240\u6709\u65f6\u95f4\u6233\u95f4\u9694\u90fd\u5728\u9884\u671f\u76841\u5206\u949f\u8303\u56f4\u5185\uff08\u5141\u8bb80\u79d2\u8bef\u5dee\uff09\")\n        else:\n            # \u8ba1\u7b97\u4e0d\u7b26\u5408\u9884\u671f\u7684\u95f4\u9694\u6570\u91cf\n            non_compliant = sum(1 for interval in intervals if abs(interval - one_minute_micros) &gt; tolerance)\n            print(f\"\u26a0\ufe0f \u53d1\u73b0 {non_compliant}/{len(intervals)} \u4e2a\u65f6\u95f4\u6233\u95f4\u9694\u4e0d\u7b26\u5408\u9884\u671f\u76841\u5206\u949f\")\n\n            # \u5982\u679c\u4e0d\u7b26\u5408\u7684\u95f4\u9694\u592a\u591a\uff0c\u53ef\u4ee5\u9009\u62e9\u4fee\u590d\u6216\u7ed9\u51fa\u8b66\u544a\n            if non_compliant &gt; len(intervals) * 0.1:  # \u5982\u679c\u8d85\u8fc710%\u7684\u95f4\u9694\u4e0d\u7b26\u5408\u9884\u671f\n                print(\"\u26a0\ufe0f \u8b66\u544a: \u5927\u91cf\u65f6\u95f4\u6233\u95f4\u9694\u4e0d\u7b26\u5408\u9884\u671f\uff0c\u53ef\u80fd\u4f1a\u5f71\u54cd\u56de\u6d4b\u51c6\u786e\u6027\")\n\n    print(f\"\u521d\u59cb\u5316\u4e86 {len(timestamps)} \u4e2a\u65f6\u95f4\u6233\uff0c\u4ece {start_date} \u5230 {end_date}\")\n    if timestamps:\n        first_dt = datetime.fromtimestamp(timestamps[0]/1000000)\n        last_dt = datetime.fromtimestamp(timestamps[-1]/1000000)\n        print(f\"\u65f6\u95f4\u6233\u8303\u56f4: {first_dt.isoformat()} \u5230 {last_dt.isoformat()}\")\n\n    # \u521b\u5efa\u5b9e\u4f8b\u5e76\u8bbe\u7f6e\u65f6\u95f4\u6233\n    instance = cls(library=library)\n\n\n    instance.timestamps = timestamps\n    instance.now_index = timestamps[0]\n    instance.interval = expected_interval_micros\n    print(f\"\u8d77\u59cb\u65f6\u95f4\u6233: {instance.now_index} ({datetime.fromtimestamp(instance.now_index/1000000).isoformat()})\")   \n\n    # \u521d\u59cb\u5316\u6a21\u62df\u8d26\u6237\u6570\u636e\n    instance.monitor_account = {\n        \"makerCommission\": 15,\n        \"takerCommission\": 15,\n        \"buyerCommission\": 0,\n        \"sellerCommission\": 0,\n        \"commissionRates\": {\n            \"maker\": \"0.00150000\",\n            \"taker\": \"0.00150000\",\n            \"buyer\": \"0.00000000\",\n            \"seller\": \"0.00000000\"\n        },\n        \"canTrade\": True,\n        \"canWithdraw\": True,\n        \"canDeposit\": True,\n        \"brokered\": False,\n        \"requireSelfTradePrevention\": False,\n        \"preventSor\": False,\n        \"updateTime\": 0,\n        \"accountType\": \"SPOT\",\n        \"balances\": [],\n        \"permissions\": [\n            \"SPOT\"\n        ],\n        \"uid\": 123456789\n    }\n\n    # \u6dfb\u52a0 USDT \u4f59\u989d\n    instance.monitor_account[\"balances\"].append({\n        \"asset\": \"USDT\",\n        \"free\": \"10000.00000000\",\n        \"locked\": \"0.00000000\"\n    })\n\n    # \u6dfb\u52a0\u6240\u6709\u4ea4\u6613\u5bf9\u7684\u57fa\u7840\u8d27\u5e01\u4f59\u989d\n    for symbol in symbols:\n        base_asset = symbol.replace(\"USDT\", \"\")\n        instance.monitor_account[\"balances\"].append({\n            \"asset\": base_asset,\n            \"free\": \"0.00000000\",\n            \"locked\": \"0.00000000\"\n        })\n\n    return instance\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiOffline.exchange_info","title":"exchange_info","text":"<pre><code>exchange_info(\n    symbol: str | None = None,\n    symbols: list[str] | None = None,\n    permissions: list[str] | None = None,\n) -&gt; None\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>def exchange_info(\n    self,\n    symbol: str | None = None,\n    symbols: list[str] | None = None,\n    permissions: list[str] | None = None,\n) -&gt; None:\n\n    # TODO(liblaf): Implement.\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiOffline.klines","title":"klines","text":"<pre><code>klines(\n    symbol: str,\n    interval: Interval,\n    *,\n    start_time: datetime | None = None,\n    **kwargs,\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>@override\ndef klines(\n    self,\n    symbol: str,\n    interval: Interval,\n    *,\n    start_time: datetime | None = None,\n    **kwargs,\n) -&gt; DataFrame:\n    import polars as pl\n\n    symbol_key = f\"{symbol}_klines_{interval}\"\n    if not self.library.has_symbol(symbol_key):\n        raise ValueError(f\"Symbol {symbol_key} not found in library\")\n\n    # \u8bfb\u53d6\u6570\u636e\n    df = self.library.read(symbol_key).data\n\n    # \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u6233\u7684\u6570\u636e\u884c\n    klines_now = df[df.index == self.now_index]\n\n    # \u68c0\u67e5\u6570\u636e\u662f\u5426\u5b58\u5728\n    if klines_now.empty:\n        print(f\"\u8b66\u544a: \u65f6\u95f4\u6233 {self.now_index} \u7684\u6570\u636e\u4e0d\u5b58\u5728\")\n        return pl.DataFrame()\n\n    # \u5217\u540d\u6620\u5c04 - \u4ece ArcticDB \u683c\u5f0f\u8f6c\u6362\u4e3a Polars \u683c\u5f0f\n    column_mapping = {\n        'Open Time': 'open_time',\n        'Open': 'open',\n        'High': 'high',\n        'Low': 'low',\n        'Close': 'close',\n        'Volume': 'volume',\n        'Close Time': 'close_time',  # \u7d22\u5f15\u5217\u4e5f\u9700\u8981\u6620\u5c04\n        'Quote Asset Volume': 'quote_volume',\n        'Number of Trades': 'count',\n        'Taker Buy Base Volume': 'taker_buy_volume',\n        'Taker Buy Quote Volume': 'taker_buy_quote_volume',\n        'Ignore': 'ignore'\n    }\n\n    # \u91cd\u7f6e\u7d22\u5f15\uff0c\u4f7f Close Time \u6210\u4e3a\u666e\u901a\u5217\n    klines_now = klines_now.reset_index()\n\n    # \u91cd\u547d\u540d\u5217\n    renamed_cols = {}\n    for old_col, new_col in column_mapping.items():\n        if old_col in klines_now.columns:\n            renamed_cols[old_col] = new_col\n\n    klines_now = klines_now.rename(columns=renamed_cols)\n\n    # \u8f6c\u6362\u4e3a Polars DataFrame\n    pl_data = pl.from_pandas(klines_now)\n\n    # \u786e\u4fdd\u8fd4\u56de\u7684 DataFrame \u6709\u6b63\u786e\u7684\u5217\u7c7b\u578b\n    schema = {\n        'open_time': int,\n        'open': pl.Float64,\n        'high': pl.Float64,\n        'low': pl.Float64,\n        'close': pl.Float64,\n        'volume': pl.Float64,\n        'close_time': int,\n        'quote_volume': pl.Float64,\n        'count': pl.Int64,\n        'taker_buy_volume': pl.Float64,\n        'taker_buy_quote_volume': pl.Float64,\n        'ignore': pl.Int64\n    }\n\n    # \u5e94\u7528\u7c7b\u578b\u8f6c\u6362\n    for col, dtype in schema.items():\n        if col in pl_data.columns:\n            if dtype == pl.Datetime and pl_data[col].dtype != pl.Datetime:\n                # \u5982\u679c\u662f\u65e5\u671f\u5217\u4e14\u9700\u8981\u8f6c\u6362\n                if pl_data[col].dtype in (pl.Int64, pl.Float64):\n                    # \u5047\u8bbe\u65f6\u95f4\u6233\u662f\u5fae\u79d2\u7ea7\u7684\n                    pl_data = pl_data.with_columns(\n                        pl.col(col).cast(pl.Int64).cast(pl.Datetime(time_unit=\"us\"))\n                    )\n            else:\n                # \u5176\u4ed6\u5217\u7c7b\u578b\u8f6c\u6362\n                pl_data = pl_data.with_columns(\n                    pl.col(col).cast(dtype)\n                )\n\n\n    return pl_data\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiOffline.order_market","title":"order_market","text":"<pre><code>order_market(\n    symbol: str,\n    side: OrderSideLike,\n    *,\n    quantity: float | None = None,\n    quoteOrderQty: float | None = None,\n    timestamp: datetime | None = None,\n    lock_rate: float = 1.0,\n    **kwargs,\n) -&gt; OrderResponseFull\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>@override\ndef order_market(\n    self,\n    symbol: str,\n    side: OrderSideLike,\n    *,\n    quantity: float | None = None,\n    quoteOrderQty: float | None = None,\n    timestamp: datetime | None = None,\n    lock_rate: float = 1.0,  # \u4fdd\u8bc1\u91d1\u500d\u6570\u53c2\u6570\uff0c\u9ed8\u8ba4\u4e3a1\u500d\n    **kwargs,\n) -&gt; OrderResponseFull:\n    now = self.now_index\n    transaction_fee = 0.001  # \u4ea4\u6613\u8d39\u7528\u4e3a0.1%\n\n    try:\n        # \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u70b9\u7684\u4ef7\u683c\u6570\u636e\n        symbol_key = f\"{symbol}_klines_1m\"\n\n        if not self.library.has_symbol(symbol_key):\n            raise ValueError(f\"Symbol {symbol_key} not found in library\")\n\n        # \u8bfb\u53d6\u6570\u636e\n        df = self.library.read(symbol_key).data\n\n        # \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u6233\u5bf9\u5e94\u7684\u884c\n        price_row = df[df.index == now]\n\n        if price_row.empty:\n            raise ValueError(f\"No price data found for timestamp {now}\")\n\n        # \u83b7\u53d6\u6536\u76d8\u4ef7\u5e76\u786e\u4fdd\u662ffloat\u7c7b\u578b\n        try:\n            price = float(price_row['Close'].iloc[0])\n        except (ValueError, TypeError):\n            # \u5982\u679c\u8f6c\u6362\u5931\u8d25\uff0c\u5c1d\u8bd5\u5176\u4ed6\u5217\u540d\uff08\u5927\u5c0f\u5199\u4e0d\u540c\uff09\n            try:\n                price = float(price_row['close'].iloc[0])\n            except (ValueError, TypeError, KeyError):\n                raise ValueError(f\"\u65e0\u6cd5\u83b7\u53d6\u6709\u6548\u7684\u6536\u76d8\u4ef7\u683c\u6570\u636e (\u65f6\u95f4\u6233: {now})\")\n\n        print(f\"\u6267\u884c\u5e02\u4ef7\u5355: {symbol}, \u65b9\u5411: {side}, \u4ef7\u683c: {price}, \u6570\u91cf: {quantity}\")\n\n        # \u4ea4\u6613\u7684\u57fa\u7840\u8d44\u4ea7\u548c\u62a5\u4ef7\u8d44\u4ea7\n        base_asset = symbol.replace(\"USDT\", \"\")\n        quote_asset = \"USDT\"\n\n        # \u8f85\u52a9\u51fd\u6570\uff1a\u83b7\u53d6\u8d44\u4ea7\u4f59\u989d\n        def get_asset_balance(asset, balance_type=\"free\"):\n            for balance in self.monitor_account[\"balances\"]:\n                if balance[\"asset\"] == asset:\n                    return float(balance[balance_type])\n            return 0.0\n\n        # \u8f85\u52a9\u51fd\u6570\uff1a\u66f4\u65b0\u8d44\u4ea7\u4f59\u989d\n        def update_asset_balance(asset, amount, balance_type=\"free\"):\n            for balance in self.monitor_account[\"balances\"]:\n                if balance[\"asset\"] == asset:\n                    current_amount = float(balance[balance_type])\n                    balance[balance_type] = str(current_amount + amount)\n                    return\n\n            # \u5982\u679c\u8d44\u4ea7\u4e0d\u5b58\u5728\uff0c\u6dfb\u52a0\u65b0\u8d44\u4ea7\n            new_balance = {\n                \"asset\": asset,\n                \"free\": \"0.00000000\",\n                \"locked\": \"0.00000000\"\n            }\n            new_balance[balance_type] = str(amount)\n            self.monitor_account[\"balances\"].append(new_balance)\n\n        # \u4e70\u5165\u903b\u8f91\n        if side == \"BUY\":\n            if quantity is None:\n                raise ValueError(\"Must provide quantity for BUY order\")\n\n            # \u8ba1\u7b97\u6240\u9700\u7684USDT\u91d1\u989d\uff08\u5305\u542b\u624b\u7eed\u8d39\uff09\n            quote_amount = quantity * price\n            fee_amount = quote_amount * transaction_fee\n            total_cost = quote_amount + fee_amount\n\n            # \u68c0\u67e5\u4f59\u989d\u662f\u5426\u8db3\u591f\n            usdt_free = get_asset_balance(quote_asset)\n            if usdt_free &lt; total_cost:\n                raise ValueError(f\"Insufficient {quote_asset} balance: {usdt_free} &lt; {total_cost}\")\n\n            # \u76f4\u63a5\u6263\u9664USDT\u4f59\u989d\n            update_asset_balance(quote_asset, -total_cost)\n            # \u589e\u52a0\u57fa\u7840\u8d44\u4ea7\n            update_asset_balance(base_asset, quantity)\n\n            print(f\"\u4e70\u5165 {quantity} {base_asset} \u82b1\u8d39 {total_cost} {quote_asset} (\u542b\u624b\u7eed\u8d39 {fee_amount})\")\n\n        # \u5356\u51fa\u903b\u8f91\n        elif side == \"SELL\":\n            if quantity is None:\n                raise ValueError(\"Must provide quantity for SELL order\")\n\n            # \u68c0\u67e5\u57fa\u7840\u8d44\u4ea7\u4f59\u989d\n            base_free = get_asset_balance(base_asset)\n\n            # \u8ba1\u7b97\u5356\u51fa\u7684USDT\u91d1\u989d\n            quote_amount = quantity * price\n            fee_amount = quote_amount * transaction_fee\n            net_received = quote_amount - fee_amount\n\n            # \u60c5\u51b51: \u6709\u8db3\u591f\u4f59\u989d\u76f4\u63a5\u5356\u51fa\n            if base_free &gt;= quantity:\n                update_asset_balance(base_asset, -quantity)\n                update_asset_balance(quote_asset, net_received)\n                print(f\"\u5356\u51fa {quantity} {base_asset} \u83b7\u5f97 {net_received} {quote_asset} (\u6263\u9664\u624b\u7eed\u8d39 {fee_amount})\")\n\n            # \u60c5\u51b52: \u4f59\u989d\u4e0d\u8db3\uff0c\u5148\u5356\u51fa\u5df2\u6709\u4f59\u989d\uff0c\u518d\u505a\u7a7a\u5269\u4f59\u90e8\u5206\n            else:\n                # \u5206\u4e24\u90e8\u5206\u5904\u7406\n                # 1. \u5148\u5356\u51fa\u5df2\u6709\u7684\u4f59\u989d\n                if base_free &gt; 0:\n                    partial_quote_amount = base_free * price\n                    partial_fee = partial_quote_amount * transaction_fee\n                    partial_net = partial_quote_amount - partial_fee\n\n                    update_asset_balance(base_asset, -base_free)\n                    update_asset_balance(quote_asset, partial_net)\n                    print(f\"\u5356\u51fa\u53ef\u7528\u4f59\u989d {base_free} {base_asset} \u83b7\u5f97 {partial_net} {quote_asset}\")\n\n                # 2. \u5269\u4f59\u90e8\u5206\u4f7f\u7528\u4fdd\u8bc1\u91d1\u505a\u7a7a\n                remaining_quantity = quantity - base_free\n                short_quote_amount = remaining_quantity * price\n                short_fee = short_quote_amount * transaction_fee\n\n                # \u8ba1\u7b97\u9700\u8981\u9501\u5b9a\u7684\u4fdd\u8bc1\u91d1 (\u4f7f\u7528lock_rate\u500d\u4fdd\u8bc1\u91d1)\n                required_margin = short_quote_amount / lock_rate\n\n                # \u68c0\u67e5USDT\u4f59\u989d\u662f\u5426\u8db3\u591f\u4f5c\u4e3a\u4fdd\u8bc1\u91d1\n                if get_asset_balance(quote_asset) &lt; required_margin:\n                    raise ValueError(f\"Insufficient {quote_asset} for margin: {get_asset_balance(quote_asset)} &lt; {required_margin}\")\n\n                # \u9501\u5b9a\u4fdd\u8bc1\u91d1 (\u4ecefree\u79fb\u5230locked)\n                update_asset_balance(quote_asset, -required_margin)\n                update_asset_balance(quote_asset, required_margin, \"locked\")\n\n                # \u521b\u5efa\u505a\u7a7a\u5934\u5bf8\u8bb0\u5f55 (\u53ef\u4ee5\u6dfb\u52a0\u5230\u76d1\u63a7\u8d26\u6237\u7684\u989d\u5916\u5b57\u6bb5\u4e2d)\n                # \u8fd9\u91cc\u7b80\u5316\u5904\u7406\uff0c\u53ea\u5728base_asset\u4e2d\u8bb0\u5f55\u8d1f\u6570\u4f59\u989d\n                update_asset_balance(base_asset, -remaining_quantity)\n                update_asset_balance(quote_asset, short_quote_amount - short_fee)\n\n                print(f\"\u505a\u7a7a {remaining_quantity} {base_asset} \u4f7f\u7528\u4fdd\u8bc1\u91d1 {required_margin} {quote_asset} (\u6760\u6746\u7387: {lock_rate})\")\n                print(f\"\u505a\u7a7a\u83b7\u5f97 {short_quote_amount - short_fee} {quote_asset} (\u6263\u9664\u624b\u7eed\u8d39 {short_fee})\")\n\n        # \u521b\u5efa\u8ba2\u5355\u54cd\u5e94\u5bf9\u8c61\n        from qoc.api.typing import OrderResponseFull, OrderResponseFill, OrderType, OrderSide\n        import datetime\n        import uuid\n\n        # \u521b\u5efa\u4e00\u4e2a\u552f\u4e00\u7684\u5ba2\u6237\u7aef\u8ba2\u5355ID\n        client_order_id = f\"offline_{uuid.uuid4().hex[:16]}\"\n\n        # \u521b\u5efafills\u5217\u8868 (\u6210\u4ea4\u660e\u7ec6)\n        fills = [\n            OrderResponseFill(\n                price=price,\n                qty=quantity,\n                commission=fee_amount,  # \u624b\u7eed\u8d39\n                commissionasset=quote_asset,  # \u624b\u7eed\u8d39\u8d44\u4ea7\n                tradeid=int(now % 1000000)  # \u4f7f\u7528\u65f6\u95f4\u6233\u90e8\u5206\u4f5c\u4e3a\u4ea4\u6613ID\n            )\n        ]\n\n        # \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u4f5c\u4e3a\u4ea4\u6613\u65f6\u95f4\n        current_time = datetime.datetime.fromtimestamp(now / 1000000)\n\n        # \u8f6c\u6362side\u5b57\u7b26\u4e32\u4e3aOrderSide\u679a\u4e3e\n        order_side = OrderSide(side)\n\n        # \u6784\u5efa\u5e76\u8fd4\u56deOrderResponseFull\u5bf9\u8c61\n        return OrderResponseFull(\n            symbol=symbol,\n            clientorderid=client_order_id,\n            transacttime=current_time,\n            price=price,\n            origqty=quantity if quantity is not None else 0.0,\n            executedqty=quantity if quantity is not None else 0.0,\n            origquoteorderqty=quoteOrderQty if quoteOrderQty is not None else 0.0,\n            cummulativequoteqty=quote_amount if 'quote_amount' in locals() else 0.0,  # \u603b\u4ef7\u503c\n            type=OrderType.MARKET,  # \u5e02\u4ef7\u5355\n            side=order_side,\n            workingtime=current_time,\n            fills=fills,\n            # \u6dfb\u52a0\u6269\u5c55\u5c5e\u6027 (\u5982\u679c\u652f\u6301\u7684\u8bdd)\n            # lockRate is not a valid parameter, removing it\n            # isShort is not a valid parameter, removing it\n        )\n\n    except Exception as e:\n        print(f\"\u6267\u884c\u5e02\u4ef7\u5355\u51fa\u9519: {e}\")\n        raise\n</code></pre>"},{"location":"reference/qoc/#qoc.ApiOffline.step","title":"step","text":"<pre><code>step() -&gt; bool\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>def step(self) -&gt; bool:\n    if self.now_index + self.interval &lt;= self.timestamps[-1]:\n        self.now_index += self.interval\n        print(f\"\u65f6\u95f4\u63a8\u8fdb\u5230: {self.now_index} \")\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/qoc/#qoc.Balance","title":"Balance","text":"<p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>symbols</code>               (<code>list[str]</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>step</code>             \u2013              </li> <li> <code>step_offline</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>symbols</code>               (<code>list[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/#qoc.Balance.library","title":"library  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library: Library = field()\n</code></pre>"},{"location":"reference/qoc/#qoc.Balance.symbols","title":"symbols  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbols: list[str] = field(factory=list)\n</code></pre>"},{"location":"reference/qoc/#qoc.Balance.step","title":"step","text":"<pre><code>step(\n    api: ApiBinance | ApiOffline,\n    market: Market,\n    now: datetime,\n) -&gt; None\n</code></pre> Source code in <code>src/qoc/balance/_balance.py</code> <pre><code>def step(self, api: _api.ApiBinance|_api.ApiOffline, market: market.Market, now: datetime) -&gt; None:\n    account: _api.Account = api.account()\n    balances_dict: dict[str, float] = {\n        b.asset: b.free + b.locked for b in account.balances\n    }\n    balances_df: pl.DataFrame = pl.from_dicts([balances_dict])\n    balances_df = utils.insert_time(balances_df, now)\n    self.library.append(\"balance\", balances_df)\n</code></pre>"},{"location":"reference/qoc/#qoc.Balance.step_offline","title":"step_offline","text":"<pre><code>step_offline(market, library, coins, interval, now) -&gt; None\n</code></pre> Source code in <code>src/qoc/balance/_balance.py</code> <pre><code>def step_offline(self, market, library, coins, interval, now) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/qoc/#qoc.CaseInsensitiveEnum","title":"CaseInsensitiveEnum","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"reference/qoc/#qoc.Database","title":"Database","text":"<pre><code>Database(uri: str = 'mem://')\n</code></pre> <p>Methods:</p> <ul> <li> <code>get_library</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>db</code>               (<code>Arctic</code>)           \u2013            </li> </ul> Source code in <code>src/qoc/database/_database.py</code> <pre><code>def __init__(self, uri: str = \"mem://\") -&gt; None:\n    self.db = adb.Arctic(uri=uri)\n</code></pre>"},{"location":"reference/qoc/#qoc.Database.db","title":"db  <code>instance-attribute</code>","text":"<pre><code>db: Arctic = Arctic(uri=uri)\n</code></pre>"},{"location":"reference/qoc/#qoc.Database.get_library","title":"get_library","text":"<pre><code>get_library(\n    name: str, *, create_if_missing: bool = True, **kwargs\n) -&gt; Library\n</code></pre> Source code in <code>src/qoc/database/_database.py</code> <pre><code>def get_library(\n    self, name: str, *, create_if_missing: bool = True, **kwargs\n) -&gt; Library:\n    return Library(\n        self.db.get_library(name, create_if_missing=create_if_missing, **kwargs)\n    )\n</code></pre>"},{"location":"reference/qoc/#qoc.Library","title":"Library","text":"<p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>append</code>             \u2013              </li> <li> <code>append_batch</code>             \u2013              </li> <li> <code>get_latest_time</code>             \u2013              </li> <li> <code>has_symbol</code>             \u2013              </li> <li> <code>read</code>             \u2013              </li> <li> <code>tail</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/#qoc.Library.library","title":"library  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library: Library = field()\n</code></pre>"},{"location":"reference/qoc/#qoc.Library.append","title":"append","text":"<pre><code>append(\n    symbol: str, data: NormalizableType, /, **kwargs\n) -&gt; None\n</code></pre> Source code in <code>src/qoc/database/_library.py</code> <pre><code>@grapes.timer(\n    cb_stop=grapes.timing.callback.log_record(level=\"WARNING\", threshold_sec=0.0)\n)\ndef append(self, symbol: str, data: NormalizableType, /, **kwargs) -&gt; None:\n    data = self._normalize_data(data)\n    if self.has_symbol(symbol):\n        data = data[data.index &gt; self.get_latest_time(symbol)]\n    if data.empty:\n        return\n    self.library.append(symbol, data, **kwargs)\n</code></pre>"},{"location":"reference/qoc/#qoc.Library.append_batch","title":"append_batch","text":"<pre><code>append_batch(\n    data: Iterable[tuple[str, NormalizableType]],\n    /,\n    **kwargs,\n) -&gt; None\n</code></pre> Source code in <code>src/qoc/database/_library.py</code> <pre><code>@grapes.timer(\n    cb_stop=grapes.timing.callback.log_record(level=\"WARNING\", threshold_sec=0.0)\n)\ndef append_batch(\n    self, data: Iterable[tuple[str, NormalizableType]], /, **kwargs\n) -&gt; None:\n    payloads: list[adb.WritePayload] = []\n    for symbol, df in data:\n        df_normalized: pd.DataFrame = self._normalize_data(df)\n        if not df_normalized.empty:\n            payloads.append(adb.WritePayload(symbol, df_normalized))\n    self.library.append_batch(payloads, **kwargs)\n</code></pre>"},{"location":"reference/qoc/#qoc.Library.get_latest_time","title":"get_latest_time","text":"<pre><code>get_latest_time(symbol: str) -&gt; int\n</code></pre> Source code in <code>src/qoc/database/_library.py</code> <pre><code>def get_latest_time(self, symbol: str, /) -&gt; int:\n    data: pd.DataFrame = cast(\n        \"pd.DataFrame\", self.library.tail(symbol=symbol, n=1).data\n    )\n\n    latest_index = data.index[-1] \n\n    return latest_index\n</code></pre>"},{"location":"reference/qoc/#qoc.Library.has_symbol","title":"has_symbol","text":"<pre><code>has_symbol(symbol: str) -&gt; bool\n</code></pre> Source code in <code>src/qoc/database/_library.py</code> <pre><code>def has_symbol(self, symbol: str, /) -&gt; bool:\n    return self.library.has_symbol(symbol)\n</code></pre>"},{"location":"reference/qoc/#qoc.Library.read","title":"read","text":"<pre><code>read(\n    symbol: str,\n    date_range: tuple[TimeTypes | None, TimeTypes | None]\n    | None = None,\n    row_range: tuple[int, int] | None = None,\n    columns: Sequence[str] | None = None,\n    **kwargs,\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/database/_library.py</code> <pre><code>def read(\n    self,\n    symbol: str,\n    date_range: tuple[TimeTypes | None, TimeTypes | None] | None = None,\n    row_range: tuple[int, int] | None = None,\n    columns: Sequence[str] | None = None,\n    **kwargs,\n) -&gt; pd.DataFrame:\n    return cast(\n        \"pd.DataFrame\",\n        self.library.read(\n            symbol=symbol,\n            date_range=date_range,\n            row_range=row_range,\n            columns=columns,  # pyright: ignore[reportArgumentType]\n            **kwargs,\n        ).data,\n    )\n</code></pre>"},{"location":"reference/qoc/#qoc.Library.tail","title":"tail","text":"<pre><code>tail(\n    symbol: str,\n    n: int = 5,\n    columns: Sequence[str] | None = None,\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/database/_library.py</code> <pre><code>def tail(\n    self, symbol: str, n: int = 5, columns: Sequence[str] | None = None\n) -&gt; pd.DataFrame:\n    return cast(\n        \"pd.DataFrame\",\n        self.library.tail(symbol=symbol, n=n, columns=columns).data,  \n    )\n</code></pre>"},{"location":"reference/qoc/#qoc.Market","title":"Market","text":"<p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>symbols</code>               (<code>list[str]</code>, default:                   <code>['BTCUSDT']</code> )           \u2013            </li> <li> <code>interval</code>               (<code>TypeAliasType</code>, default:                   <code>'1s'</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>step</code>             \u2013              </li> <li> <code>tail</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>interval</code>               (<code>Interval</code>)           \u2013            </li> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>symbols</code>               (<code>list[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/#qoc.Market.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interval: Interval = field(default='1s')\n</code></pre>"},{"location":"reference/qoc/#qoc.Market.library","title":"library  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library: Library = field()\n</code></pre>"},{"location":"reference/qoc/#qoc.Market.symbols","title":"symbols  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbols: list[str] = field(factory=lambda: ['BTCUSDT'])\n</code></pre>"},{"location":"reference/qoc/#qoc.Market.convert","title":"convert","text":"<pre><code>convert(qty: float, base: str, quote: str) -&gt; float\n</code></pre> Source code in <code>src/qoc/market/_market.py</code> <pre><code>def convert(self, qty: float, base: str, quote: str) -&gt; float:\n    if base == quote:\n        return qty\n    df: pd.DataFrame = self.library.tail(f\"{base}{quote}\", n=1, columns=[\"close\"])\n    price: float = df[\"close\"].iloc[-1]\n    return qty * price\n</code></pre>"},{"location":"reference/qoc/#qoc.Market.step","title":"step","text":"<pre><code>step(api: ApiBinance | ApiOffline) -&gt; None\n</code></pre> Source code in <code>src/qoc/market/_market.py</code> <pre><code>def step(self, api: api.ApiBinance|api.ApiOffline) -&gt; None:\n    for symbol in self.symbols:\n        klines: pl.DataFrame = api.klines(symbol, self.interval)\n        # ic(klines)\n\n        self.library.append(symbol, klines)\n</code></pre>"},{"location":"reference/qoc/#qoc.Market.tail","title":"tail","text":"<pre><code>tail(\n    symbol: str,\n    n: int = 5,\n    columns: Sequence[str] | None = None,\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/market/_market.py</code> <pre><code>def tail(\n    self, symbol: str, n: int = 5, columns: Sequence[str] | None = None\n) -&gt; pd.DataFrame:\n    return self.library.tail(symbol, n=n, columns=columns)\n</code></pre>"},{"location":"reference/qoc/#qoc.Snap","title":"Snap","text":"<p>               Bases: <code>StrEnum</code></p> <p>Methods:</p> <ul> <li> <code>ceil</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>NONE</code>           \u2013            </li> <li> <code>SECOND</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/#qoc.Snap.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = auto()\n</code></pre>"},{"location":"reference/qoc/#qoc.Snap.SECOND","title":"SECOND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SECOND = auto()\n</code></pre>"},{"location":"reference/qoc/#qoc.Snap.ceil","title":"ceil","text":"<pre><code>ceil(time: datetime) -&gt; datetime\n</code></pre> Source code in <code>src/qoc/utils/_clock.py</code> <pre><code>def ceil(self, time: datetime.datetime) -&gt; datetime.datetime:\n    match self:\n        case Snap.NONE:\n            return time\n        case Snap.SECOND:\n            if time.microsecond &gt; 0:\n                time += datetime.timedelta(seconds=1)\n            return time.replace(microsecond=0)\n        case v:\n            raise grapes.error.MatchError(v)\n</code></pre>"},{"location":"reference/qoc/#qoc.Strategy","title":"Strategy","text":"<p>               Bases: <code>ABC</code></p> <p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>dump</code>             \u2013              </li> <li> <code>step</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/#qoc.Strategy.library","title":"library  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library: Library = field(metadata={'dump': False})\n</code></pre>"},{"location":"reference/qoc/#qoc.Strategy.dump","title":"dump  <code>abstractmethod</code>","text":"<pre><code>dump(now: datetime) -&gt; None\n</code></pre> Source code in <code>src/qoc/strategy/_abc.py</code> <pre><code>@abc.abstractmethod\ndef dump(self, now: datetime.datetime) -&gt; None: ...\n</code></pre>"},{"location":"reference/qoc/#qoc.Strategy.step","title":"step  <code>abstractmethod</code>","text":"<pre><code>step(\n    api: ApiBinance, market: Market, now: datetime\n) -&gt; None\n</code></pre> Source code in <code>src/qoc/strategy/_abc.py</code> <pre><code>@abc.abstractmethod\ndef step(\n    self, api: api.ApiBinance, market: market.Market, now: datetime.datetime\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/qoc/#qoc.StrategySingleSymbol","title":"StrategySingleSymbol","text":"<p>               Bases: <code>Strategy</code></p> <p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>symbols</code>               (<code>list[str]</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>dump</code>             \u2013              </li> <li> <code>step</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>symbol</code>               (<code>str</code>)           \u2013            </li> <li> <code>symbols</code>               (<code>list[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/#qoc.StrategySingleSymbol.library","title":"library  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library: Library = field(metadata={'dump': False})\n</code></pre>"},{"location":"reference/qoc/#qoc.StrategySingleSymbol.symbol","title":"symbol  <code>property</code>","text":"<pre><code>symbol: str\n</code></pre>"},{"location":"reference/qoc/#qoc.StrategySingleSymbol.symbols","title":"symbols  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbols: list[str] = field(\n    factory=list, metadata={\"dump\": False}\n)\n</code></pre>"},{"location":"reference/qoc/#qoc.StrategySingleSymbol.dump","title":"dump","text":"<pre><code>dump(now: datetime) -&gt; None\n</code></pre> Source code in <code>src/qoc/strategy/_abc.py</code> <pre><code>@override\ndef dump(self, now: datetime.datetime) -&gt; None:\n    data: pl.DataFrame = pl.from_dicts(\n        [attrs.asdict(self, filter=self._dump_filter)]\n    )\n    data = data.insert_column(0, pl.Series(\"time\", [now]))\n\n    # Dump data for each symbol\n    for symbol in self.symbols:\n        self.library.append(symbol, data)\n</code></pre>"},{"location":"reference/qoc/#qoc.StrategySingleSymbol.step","title":"step  <code>abstractmethod</code>","text":"<pre><code>step(\n    api: ApiBinance, market: Market, now: datetime\n) -&gt; None\n</code></pre> Source code in <code>src/qoc/strategy/_abc.py</code> <pre><code>@abc.abstractmethod\ndef step(\n    self, api: api.ApiBinance, market: market.Market, now: datetime.datetime\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/qoc/#qoc.clock","title":"clock","text":"<pre><code>clock(\n    interval: timedelta = timedelta(seconds=1),\n    *,\n    end: datetime | None = None,\n    max_duration: timedelta | None = None,\n    max_iter: int | None = None,\n    offline: bool = False,\n    snap: SnapLike = NONE,\n    start: datetime | None = None,\n) -&gt; Generator[datetime]\n</code></pre> Source code in <code>src/qoc/utils/_clock.py</code> <pre><code>def clock(\n    interval: datetime.timedelta = datetime.timedelta(seconds=1),\n    *,\n    end: datetime.datetime | None = None,\n    max_duration: datetime.timedelta | None = None,\n    max_iter: int | None = None,\n    offline: bool = False,\n    snap: SnapLike = Snap.NONE,\n    start: datetime.datetime | None = None,\n) -&gt; Generator[datetime.datetime]:\n    snap = Snap(snap)\n    if start is None:\n        start = datetime.datetime.now(tz=datetime.UTC)\n    start = snap.ceil(start)\n    if max_duration is not None:\n        # Ensure the clock does not exceed either the specified 'end' time or the maximum duration.\n        if end is not None:\n            end = min(end, start + max_duration)\n        else:\n            end = start + max_duration\n    for tick in _ticks(interval, end=end, max_iter=max_iter, start=start):\n        if offline:\n            yield tick\n            continue\n        now: datetime.datetime = datetime.datetime.now(tz=datetime.UTC)\n        sleep_for: float = (tick - now).total_seconds()\n        if sleep_for &lt;= 0:\n            logger.warning(\n                \"clock tick is behind schedule (negative sleep): {} &lt; {}\",\n                tick.isoformat(),\n                now.isoformat(),\n            )\n            continue\n        time.sleep(sleep_for)\n        logger.debug(\"clock tick: {}\", tick.isoformat())\n        yield tick\n</code></pre>"},{"location":"reference/qoc/#qoc.data_dir","title":"data_dir","text":"<pre><code>data_dir(path: str | PathLike[str] = '.') -&gt; Path\n</code></pre> Source code in <code>src/qoc/utils/_path.py</code> <pre><code>def data_dir(path: str | os.PathLike[str] = \".\") -&gt; Path:\n    path = Path(path)\n    if path.is_absolute():\n        return path\n    return working_dir() / \"data\" / path\n</code></pre>"},{"location":"reference/qoc/#qoc.entrypoint","title":"entrypoint","text":"<pre><code>entrypoint() -&gt; Path\n</code></pre> Source code in <code>src/qoc/utils/_path.py</code> <pre><code>def entrypoint() -&gt; Path:\n    return Path(sys.argv[0]).absolute()\n</code></pre>"},{"location":"reference/qoc/#qoc.fig_dir","title":"fig_dir","text":"<pre><code>fig_dir(path: str | PathLike[str] = '.') -&gt; Path\n</code></pre> Source code in <code>src/qoc/utils/_path.py</code> <pre><code>def fig_dir(path: str | os.PathLike[str] = \".\") -&gt; Path:\n    path = Path(path)\n    if path.is_absolute():\n        return path\n    return working_dir() / \"fig\" / path\n</code></pre>"},{"location":"reference/qoc/#qoc.insert_time","title":"insert_time","text":"<pre><code>insert_time(\n    df: DataFrame, time: datetime, column_name: str = \"time\"\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/utils/_polars.py</code> <pre><code>def insert_time(\n    df: pl.DataFrame, time: datetime.datetime, column_name: str = \"time\"\n) -&gt; pl.DataFrame:\n    if isinstance(time, datetime.datetime):\n        time_value = int(time.timestamp() * 1000000)  # \u8f6c\u6362\u4e3a\u5fae\u79d2\u65f6\u95f4\u6233\n\n    return df.insert_column(0, pl.Series(column_name, [time_value]))\n</code></pre>"},{"location":"reference/qoc/#qoc.working_dir","title":"working_dir","text":"<pre><code>working_dir(path: str | PathLike[str] = '.') -&gt; Path\n</code></pre> Source code in <code>src/qoc/utils/_path.py</code> <pre><code>def working_dir(path: str | os.PathLike[str] = \".\") -&gt; Path:\n    path = Path(path)\n    if path.is_absolute():\n        return path\n    return entrypoint().parent / path\n</code></pre>"},{"location":"reference/qoc/api/","title":"qoc.api","text":""},{"location":"reference/qoc/api/#qoc.api","title":"qoc.api","text":"<p>Modules:</p> <ul> <li> <code>binance</code>           \u2013            </li> <li> <code>offline</code>           \u2013            </li> <li> <code>typing</code>           \u2013            </li> </ul> <p>Type Aliases:</p> <ul> <li> <code>Interval</code>           \u2013            </li> <li> <code>OrderSideLike</code>           \u2013            </li> <li> <code>OrderTypeLike</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Account</code>           \u2013            <p>.</p> </li> <li> <code>ApiBinance</code>           \u2013            </li> <li> <code>ApiOffline</code>           \u2013            </li> <li> <code>ExchangeInfo</code>           \u2013            </li> <li> <code>ExchangeInfoSymbol</code>           \u2013            </li> <li> <code>OrderResponseFill</code>           \u2013            </li> <li> <code>OrderResponseFull</code>           \u2013            </li> <li> <code>OrderSide</code>           \u2013            </li> <li> <code>OrderType</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/api/#qoc.api.Interval","title":"Interval","text":"<pre><code>Interval = Literal[\n    \"1s\",\n    \"1m\",\n    \"3m\",\n    \"5m\",\n    \"15m\",\n    \"30m\",\n    \"1h\",\n    \"2h\",\n    \"4h\",\n    \"6h\",\n    \"8h\",\n    \"12h\",\n    \"1d\",\n    \"3d\",\n    \"1w\",\n    \"1M\",\n]\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderSideLike","title":"OrderSideLike","text":"<pre><code>OrderSideLike = OrderSide | Literal['BUY', 'SELL']\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderTypeLike","title":"OrderTypeLike","text":"<pre><code>OrderTypeLike = (\n    OrderType\n    | Literal[\n        \"LIMIT\",\n        \"MARKET\",\n        \"STOP_LOSS\",\n        \"STOP_LOSS_LIMIT\",\n        \"TAKE_PROFIT\",\n        \"TAKE_PROFIT_LIMIT\",\n        \"LIMIT_MAKER\",\n    ]\n)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.Account","title":"Account","text":"<p>               Bases: <code>BaseModel</code></p> <p>.</p> Example <pre><code>{\n    \"makerCommission\": 15,\n    \"takerCommission\": 15,\n    \"buyerCommission\": 0,\n    \"sellerCommission\": 0,\n    \"commissionRates\": {\n        \"maker\": \"0.00150000\",\n        \"taker\": \"0.00150000\",\n        \"buyer\": \"0.00000000\",\n        \"seller\": \"0.00000000\"\n    },\n    \"canTrade\": true,\n    \"canWithdraw\": true,\n    \"canDeposit\": true,\n    \"brokered\": false,\n    \"requireSelfTradePrevention\": false,\n    \"preventSor\": false,\n    \"updateTime\": 123456789,\n    \"accountType\": \"SPOT\",\n    \"balances\": [\n        {\n            \"asset\": \"BTC\",\n            \"free\": \"4723846.89208129\",\n            \"locked\": \"0.00000000\"\n        },\n        {\n            \"asset\": \"LTC\",\n            \"free\": \"4763368.68006011\",\n            \"locked\": \"0.00000000\"\n        }\n    ],\n    \"permissions\": [\n        \"SPOT\"\n    ],\n    \"uid\": 354937868\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>commission_rates</code>               (<code>CommissionRates</code>)           \u2013            </li> <li> <code>balances</code>               (<code>list[Balance]</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>balances</code>               (<code>list[Balance]</code>)           \u2013            </li> <li> <code>commission_rates</code>               (<code>CommissionRates</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/api/#qoc.api.Account.balances","title":"balances  <code>instance-attribute</code>","text":"<pre><code>balances: list[Balance]\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.Account.commission_rates","title":"commission_rates  <code>instance-attribute</code>","text":"<pre><code>commission_rates: CommissionRates\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.Account.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"allow\", alias_generator=to_camel\n)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiBinance","title":"ApiBinance","text":"<p>Parameters:</p> <ul> <li> <code>client</code>               (<code>Spot</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>account</code>             \u2013              </li> <li> <code>create</code>             \u2013              </li> <li> <code>exchange_info</code>             \u2013              </li> <li> <code>klines</code>             \u2013              </li> <li> <code>order</code>             \u2013              </li> <li> <code>order_market</code>             \u2013              </li> <li> <code>ping</code>             \u2013              </li> <li> <code>step</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>client</code>               (<code>Spot</code>)           \u2013            </li> <li> <code>timeunit</code>               (<code>TimeUnit</code>)           \u2013            <p>.</p> </li> </ul>"},{"location":"reference/qoc/api/#qoc.api.ApiBinance.client","title":"client  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client: Spot = field()\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiBinance.timeunit","title":"timeunit  <code>property</code>","text":"<pre><code>timeunit: TimeUnit\n</code></pre> <p>.</p> <p>All time and timestamp related fields in the JSON responses are in milliseconds by default.</p> References <ol> <li>https://developers.binance.com/docs/binance-spot-api-docs/testnet/rest-api/general-api-information</li> </ol>"},{"location":"reference/qoc/api/#qoc.api.ApiBinance.account","title":"account","text":"<pre><code>account(**kwargs) -&gt; Account\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def account(self, **kwargs) -&gt; Account:\n    raw: dict = self.client.account(**kwargs)\n    return Account.model_validate(raw)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiBinance.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    api_key: str | None = None,\n    api_secret: str | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>@classmethod\ndef create(\n    cls, api_key: str | None = None, api_secret: str | None = None, **kwargs\n) -&gt; Self:\n    if api_key is None:\n        api_key = env.str(\"BINANCE_API_KEY\", None)\n    if api_secret is None:\n        api_secret = env.str(\"BINANCE_API_SECRET\", None)\n    if not kwargs.get(\"base_url\") and (\n        base_url := env.str(\"BINANCE_BASE_URL\", None)\n    ):\n        kwargs[\"base_url\"] = base_url\n    client = binance.spot.Spot(api_key=api_key, api_secret=api_secret, **kwargs)\n    return cls(client=client)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiBinance.exchange_info","title":"exchange_info","text":"<pre><code>exchange_info(\n    symbol: str | None = None,\n    symbols: list[str] | None = None,\n    permissions: list[str] | None = None,\n) -&gt; ExchangeInfo\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def exchange_info(\n    self,\n    symbol: str | None = None,\n    symbols: list[str] | None = None,\n    permissions: list[str] | None = None,\n) -&gt; ExchangeInfo:\n    data = self.client.exchange_info(\n        symbol=symbol,  # pyright: ignore[reportArgumentType]\n        symbols=symbols,  # pyright: ignore[reportArgumentType]\n        permissions=permissions,  # pyright: ignore[reportArgumentType]\n    )\n    return ExchangeInfo.model_validate(data)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiBinance.klines","title":"klines","text":"<pre><code>klines(\n    symbol: str,\n    interval: Interval,\n    *,\n    start_time: datetime | None = None,\n    **kwargs,\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def klines(\n    self,\n    symbol: str,\n    interval: Interval,\n    *,\n    start_time: datetime.datetime | None = None,\n    **kwargs,\n) -&gt; pl.DataFrame:\n    if start_time:\n        kwargs[\"startTime\"] = self.timeunit.from_datetime(start_time)\n    response: list[list[int | str]] = self.client.klines(\n        symbol=symbol, interval=interval, **kwargs\n    )\n    data: pl.DataFrame = pl.from_records(\n        response,\n        schema=[\n            (\n                \"open_time\",\n                pl.Datetime(time_unit=self.timeunit.to_polars),\n            ),  # Kline open time\n            (\"open\", pl.Float64),  # Open price\n            (\"high\", pl.Float64),  # High price\n            (\"low\", pl.Float64),  # Low price\n            (\"close\", pl.Float64),  # Close price\n            (\"volume\", pl.Float64),  # Volume\n            (\n                \"close_time\",\n                pl.Datetime(time_unit=self.timeunit.to_polars),\n            ),  # Kline Close time\n            (\"quote_volume\", pl.Float64),  # Quote asset volume\n            (\"count\", pl.Int64),  # Number of trades\n            (\"taker_buy_volume\", pl.Float64),  # Taker buy base asset volume\n            (\"taker_buy_quote_volume\", pl.Float64),  # Taker buy quote asset volume\n            (\"ignore\", pl.Int64),  # Unused field, ignore.\n        ],\n        orient=\"row\",\n    )\n\n\n    # \u5c06 Datetime \u65f6\u95f4\u6233\u8f6c\u6362\u4e3a\u6574\u6570\u5fae\u79d2\u65f6\u95f4\u6233\n    time_unit_multiplier = {\n        \"ns\": 0.001,  # \u7eb3\u79d2\u8f6c\u5fae\u79d2\u9700\u8981\u9664\u4ee5 1000\n        \"us\": 1,      # \u5fae\u79d2\u4fdd\u6301\u4e0d\u53d8\n        \"ms\": 1000,   # \u6beb\u79d2\u8f6c\u5fae\u79d2\u9700\u8981\u4e58\u4ee5 1000\n        \"s\": 1000000, # \u79d2\u8f6c\u5fae\u79d2\u9700\u8981\u4e58\u4ee5 1000000\n    }[self.timeunit.to_polars]\n\n    # \u8f6c\u6362\u65f6\u95f4\u5217\u4e3a\u6574\u6570\u5fae\u79d2\u65f6\u95f4\u6233\n    data = data.with_columns([\n        pl.col(\"open_time\").dt.epoch(\"us\").alias(\"open_time\"),\n        pl.col(\"close_time\").dt.epoch(\"us\").alias(\"close_time\")\n    ])\n    return data\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiBinance.order","title":"order","text":"<pre><code>order(\n    symbol: str,\n    side: OrderSideLike,\n    type_: OrderTypeLike,\n    **kwargs,\n) -&gt; OrderResponseFull\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def order(\n    self, symbol: str, side: OrderSideLike, type_: OrderTypeLike, **kwargs\n) -&gt; OrderResponseFull:\n    side = OrderSide(side)\n    type_ = OrderType(type_)\n    logger.info(\n        \"New Order &gt; symbol: {}, side: {}, type: {}, {}\",\n        symbol,\n        side,\n        type_,\n        kwargs,\n    )\n    raw: dict = self.client.new_order(\n        symbol=symbol, side=side, type=type_, **kwargs\n    )\n    response: OrderResponseFull = OrderResponseFull.model_validate(raw)\n    logger.info(response)\n    return response\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiBinance.order_market","title":"order_market","text":"<pre><code>order_market(\n    symbol: str,\n    side: OrderSideLike,\n    *,\n    quantity: float | None = None,\n    quoteOrderQty: float | None = None,\n    **kwargs,\n) -&gt; OrderResponseFull\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def order_market(\n    self,\n    symbol: str,\n    side: OrderSideLike,\n    *,\n    quantity: float | None = None,\n    quoteOrderQty: float | None = None,\n    **kwargs,\n) -&gt; OrderResponseFull:\n    if quantity is not None:\n        kwargs[\"quantity\"] = f\"{quantity:f}\"\n    if quoteOrderQty is not None:\n        kwargs[\"quoteOrderQty\"] = f\"{quoteOrderQty:f}\"\n    return self.order(symbol, side, OrderType.MARKET, **kwargs)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiBinance.ping","title":"ping","text":"<pre><code>ping() -&gt; None\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def ping(self) -&gt; None:\n    self.client.ping()\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiBinance.step","title":"step","text":"<pre><code>step() -&gt; bool\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def step(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiOffline","title":"ApiOffline","text":"<p>               Bases: <code>TradingApi</code></p> <p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>monitor_account</code>               (<code>dict</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> <li> <code>timestamps</code>               (<code>list[int]</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> </li> <li> <code>now_index</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            </li> <li> <code>interval</code>               (<code>int</code>, default:                   <code>60000000</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>account</code>             \u2013              <p>\u8fd4\u56de\u5f53\u524d\u6a21\u62df\u8d26\u6237\u4fe1\u606f</p> </li> <li> <code>create</code>             \u2013              </li> <li> <code>exchange_info</code>             \u2013              </li> <li> <code>klines</code>             \u2013              </li> <li> <code>order_market</code>             \u2013              </li> <li> <code>step</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>interval</code>               (<code>int</code>)           \u2013            </li> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>monitor_account</code>               (<code>dict</code>)           \u2013            </li> <li> <code>now_index</code>               (<code>int</code>)           \u2013            </li> <li> <code>timestamps</code>               (<code>list[int]</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/api/#qoc.api.ApiOffline.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interval: int = field(default=60 * 1000000)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiOffline.library","title":"library  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library: Library = field()\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiOffline.monitor_account","title":"monitor_account  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>monitor_account: dict = field(factory=dict)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiOffline.now_index","title":"now_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>now_index: int = field(default=0)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiOffline.timestamps","title":"timestamps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestamps: list[int] = field(factory=list)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiOffline.account","title":"account","text":"<pre><code>account(**kwargs) -&gt; Account\n</code></pre> <p>\u8fd4\u56de\u5f53\u524d\u6a21\u62df\u8d26\u6237\u4fe1\u606f</p> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>@override\ndef account(self, **kwargs) -&gt; Account:\n    \"\"\"\u8fd4\u56de\u5f53\u524d\u6a21\u62df\u8d26\u6237\u4fe1\u606f\"\"\"\n    # \u76f4\u63a5\u4f7f\u7528\u5b58\u50a8\u7684\u8d26\u6237\u6570\u636e\u7ed3\u6784\n    from qoc.api.typing import Account\n\n    # \u8fd4\u56de\u9a8c\u8bc1\u8fc7\u7684\u8d26\u6237\u5bf9\u8c61\n    return Account.model_validate(self.monitor_account)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiOffline.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    library: Library,\n    symbols: list[str],\n    start_date: str,\n    end_date: str,\n) -&gt; Self\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>@classmethod\ndef create(cls, library: adb.library.Library, symbols: list[str], start_date: str, end_date: str) -&gt; Self:\n    from datetime import datetime, timedelta\n    import pandas as pd\n\n    # \u8f6c\u6362\u65e5\u671f\u5b57\u7b26\u4e32\u4e3adatetime\u5bf9\u8c61\n    start_dt = datetime.strptime(start_date, \"%Y-%m-%d\")\n    end_dt = datetime.strptime(end_date, \"%Y-%m-%d\")\n\n    # \u521d\u59cb\u5316\u65f6\u95f4\u6233\u5217\u8868\n    timestamps = []\n\n    # \u9ed8\u8ba4\u4f7f\u75281\u5206\u949f\u95f4\u9694\n    interval = \"1m\"\n\n    # \u5b9a\u4e49\u9884\u671f\u7684\u95f4\u9694\uff08\u5fae\u79d2\uff09\n    expected_interval_micros = 60 * 1000000  # 1\u5206\u949f = 60\u79d2 = 60,000,000\u5fae\u79d2\n\n    # \u8f6c\u6362\u65e5\u671f\u8303\u56f4\u4e3a\u65f6\u95f4\u6233\uff08\u5fae\u79d2\uff09\n    start_timestamp = int(start_dt.timestamp() * 1000000)\n    end_timestamp = int(end_dt.timestamp() * 1000000)\n\n    # \u4ece\u6240\u6709\u4ea4\u6613\u5bf9\u4e2d\u6536\u96c6\u65f6\u95f4\u6233\n    all_timestamps = set()\n\n    for symbol in symbols:\n        symbol_key = f\"{symbol}_klines_{interval}\"\n\n        if symbol_key in library.list_symbols():\n            try:\n                # \u8bfb\u53d6\u6570\u636e\n                result = library.read(symbol_key).data\n\n                df_pandas: pd.DataFrame = result \n\n                # \u68c0\u67e5\u6570\u636e\u662f\u5426\u4e3a\u7a7a\n                if not df_pandas.empty:\n                    # \u83b7\u53d6\u5217\u548c\u7d22\u5f15\u4fe1\u606f\n                    columns = df_pandas.columns.tolist()\n\n                    # \u60c5\u51b51: \"Close Time\" \u4f5c\u4e3a\u666e\u901a\u5217\n                    if \"Close Time\" in columns:\n                        all_timestamps.update(\n                            ts for ts in df_pandas[\"Close Time\"] \n                            if start_timestamp &lt;= ts &lt;= end_timestamp\n                        )\n                    # \u60c5\u51b52: \u7d22\u5f15\u53ef\u80fd\u662f\u65f6\u95f4\u6233\uff08\u68c0\u67e5\u7d22\u5f15\u540d\u79f0\u6216\u7c7b\u578b\uff09\n                    elif df_pandas.index.name == \"Close Time\" or isinstance(df_pandas.index, pd.DatetimeIndex):\n                        # \u5982\u679c\u7d22\u5f15\u662fDatetimeIndex\uff0c\u9700\u8981\u8f6c\u6362\u4e3a\u5fae\u79d2\u65f6\u95f4\u6233\n                        if isinstance(df_pandas.index, pd.DatetimeIndex):\n                            index_timestamps = (df_pandas.index.astype(int) // 1000).tolist()  # \u7eb3\u79d2\u8f6c\u5fae\u79d2\n                        else:\n                            index_timestamps = df_pandas.index.tolist()\n\n                        all_timestamps.update(\n                            ts for ts in index_timestamps\n                            if start_timestamp &lt;= ts &lt;= end_timestamp\n                        )\n                    else:\n                        print(f\"\u8b66\u544a: {symbol_key} \u4e2d\u6ca1\u6709\u627e\u5230 'Close Time' \u5217\u6216\u65f6\u95f4\u7d22\u5f15\")\n\n            except Exception as e:\n                print(f\"\u5904\u7406\u4ea4\u6613\u5bf9 {symbol} \u65f6\u51fa\u9519: {e}\")\n\n    # \u5c06\u96c6\u5408\u8f6c\u6362\u4e3a\u5217\u8868\u5e76\u6392\u5e8f\n    timestamps = sorted(all_timestamps)\n\n    # \u68c0\u67e5\u65f6\u95f4\u6233\u95f4\u9694\n    if len(timestamps) &gt; 1:\n        # \u8ba1\u7b97\u6240\u6709\u76f8\u90bb\u65f6\u95f4\u6233\u4e4b\u95f4\u7684\u95f4\u9694\n        intervals = [timestamps[i+1] - timestamps[i] for i in range(len(timestamps)-1)]\n\n        # \u7edf\u8ba1\u5206\u6790\n        min_interval = min(intervals)\n        max_interval = max(intervals)\n        avg_interval = sum(intervals) / len(intervals)\n\n        print(f\"\u65f6\u95f4\u6233\u95f4\u9694\u7edf\u8ba1:\")\n        print(f\"  \u6700\u5c0f\u95f4\u9694: {min_interval} \u5fae\u79d2 ({min_interval/1000000} \u79d2)\")\n        print(f\"  \u6700\u5927\u95f4\u9694: {max_interval} \u5fae\u79d2 ({max_interval/1000000} \u79d2)\")\n        print(f\"  \u5e73\u5747\u95f4\u9694: {avg_interval} \u5fae\u79d2 ({avg_interval/1000000} \u79d2)\")\n\n        # \u68c0\u67e5\u662f\u5426\u6240\u6709\u95f4\u9694\u90fd\u7b26\u5408\u9884\u671f\n        one_minute_micros = 60 * 1000000  # 1\u5206\u949f\u7684\u5fae\u79d2\u6570\n        tolerance = 0  # \u5141\u8bb80\u8bef\u5dee\n\n        all_one_minute = all(abs(interval - one_minute_micros) &lt;= tolerance for interval in intervals)\n\n        if all_one_minute:\n            print(f\"\u2713 \u6240\u6709\u65f6\u95f4\u6233\u95f4\u9694\u90fd\u5728\u9884\u671f\u76841\u5206\u949f\u8303\u56f4\u5185\uff08\u5141\u8bb80\u79d2\u8bef\u5dee\uff09\")\n        else:\n            # \u8ba1\u7b97\u4e0d\u7b26\u5408\u9884\u671f\u7684\u95f4\u9694\u6570\u91cf\n            non_compliant = sum(1 for interval in intervals if abs(interval - one_minute_micros) &gt; tolerance)\n            print(f\"\u26a0\ufe0f \u53d1\u73b0 {non_compliant}/{len(intervals)} \u4e2a\u65f6\u95f4\u6233\u95f4\u9694\u4e0d\u7b26\u5408\u9884\u671f\u76841\u5206\u949f\")\n\n            # \u5982\u679c\u4e0d\u7b26\u5408\u7684\u95f4\u9694\u592a\u591a\uff0c\u53ef\u4ee5\u9009\u62e9\u4fee\u590d\u6216\u7ed9\u51fa\u8b66\u544a\n            if non_compliant &gt; len(intervals) * 0.1:  # \u5982\u679c\u8d85\u8fc710%\u7684\u95f4\u9694\u4e0d\u7b26\u5408\u9884\u671f\n                print(\"\u26a0\ufe0f \u8b66\u544a: \u5927\u91cf\u65f6\u95f4\u6233\u95f4\u9694\u4e0d\u7b26\u5408\u9884\u671f\uff0c\u53ef\u80fd\u4f1a\u5f71\u54cd\u56de\u6d4b\u51c6\u786e\u6027\")\n\n    print(f\"\u521d\u59cb\u5316\u4e86 {len(timestamps)} \u4e2a\u65f6\u95f4\u6233\uff0c\u4ece {start_date} \u5230 {end_date}\")\n    if timestamps:\n        first_dt = datetime.fromtimestamp(timestamps[0]/1000000)\n        last_dt = datetime.fromtimestamp(timestamps[-1]/1000000)\n        print(f\"\u65f6\u95f4\u6233\u8303\u56f4: {first_dt.isoformat()} \u5230 {last_dt.isoformat()}\")\n\n    # \u521b\u5efa\u5b9e\u4f8b\u5e76\u8bbe\u7f6e\u65f6\u95f4\u6233\n    instance = cls(library=library)\n\n\n    instance.timestamps = timestamps\n    instance.now_index = timestamps[0]\n    instance.interval = expected_interval_micros\n    print(f\"\u8d77\u59cb\u65f6\u95f4\u6233: {instance.now_index} ({datetime.fromtimestamp(instance.now_index/1000000).isoformat()})\")   \n\n    # \u521d\u59cb\u5316\u6a21\u62df\u8d26\u6237\u6570\u636e\n    instance.monitor_account = {\n        \"makerCommission\": 15,\n        \"takerCommission\": 15,\n        \"buyerCommission\": 0,\n        \"sellerCommission\": 0,\n        \"commissionRates\": {\n            \"maker\": \"0.00150000\",\n            \"taker\": \"0.00150000\",\n            \"buyer\": \"0.00000000\",\n            \"seller\": \"0.00000000\"\n        },\n        \"canTrade\": True,\n        \"canWithdraw\": True,\n        \"canDeposit\": True,\n        \"brokered\": False,\n        \"requireSelfTradePrevention\": False,\n        \"preventSor\": False,\n        \"updateTime\": 0,\n        \"accountType\": \"SPOT\",\n        \"balances\": [],\n        \"permissions\": [\n            \"SPOT\"\n        ],\n        \"uid\": 123456789\n    }\n\n    # \u6dfb\u52a0 USDT \u4f59\u989d\n    instance.monitor_account[\"balances\"].append({\n        \"asset\": \"USDT\",\n        \"free\": \"10000.00000000\",\n        \"locked\": \"0.00000000\"\n    })\n\n    # \u6dfb\u52a0\u6240\u6709\u4ea4\u6613\u5bf9\u7684\u57fa\u7840\u8d27\u5e01\u4f59\u989d\n    for symbol in symbols:\n        base_asset = symbol.replace(\"USDT\", \"\")\n        instance.monitor_account[\"balances\"].append({\n            \"asset\": base_asset,\n            \"free\": \"0.00000000\",\n            \"locked\": \"0.00000000\"\n        })\n\n    return instance\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiOffline.exchange_info","title":"exchange_info","text":"<pre><code>exchange_info(\n    symbol: str | None = None,\n    symbols: list[str] | None = None,\n    permissions: list[str] | None = None,\n) -&gt; None\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>def exchange_info(\n    self,\n    symbol: str | None = None,\n    symbols: list[str] | None = None,\n    permissions: list[str] | None = None,\n) -&gt; None:\n\n    # TODO(liblaf): Implement.\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiOffline.klines","title":"klines","text":"<pre><code>klines(\n    symbol: str,\n    interval: Interval,\n    *,\n    start_time: datetime | None = None,\n    **kwargs,\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>@override\ndef klines(\n    self,\n    symbol: str,\n    interval: Interval,\n    *,\n    start_time: datetime | None = None,\n    **kwargs,\n) -&gt; DataFrame:\n    import polars as pl\n\n    symbol_key = f\"{symbol}_klines_{interval}\"\n    if not self.library.has_symbol(symbol_key):\n        raise ValueError(f\"Symbol {symbol_key} not found in library\")\n\n    # \u8bfb\u53d6\u6570\u636e\n    df = self.library.read(symbol_key).data\n\n    # \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u6233\u7684\u6570\u636e\u884c\n    klines_now = df[df.index == self.now_index]\n\n    # \u68c0\u67e5\u6570\u636e\u662f\u5426\u5b58\u5728\n    if klines_now.empty:\n        print(f\"\u8b66\u544a: \u65f6\u95f4\u6233 {self.now_index} \u7684\u6570\u636e\u4e0d\u5b58\u5728\")\n        return pl.DataFrame()\n\n    # \u5217\u540d\u6620\u5c04 - \u4ece ArcticDB \u683c\u5f0f\u8f6c\u6362\u4e3a Polars \u683c\u5f0f\n    column_mapping = {\n        'Open Time': 'open_time',\n        'Open': 'open',\n        'High': 'high',\n        'Low': 'low',\n        'Close': 'close',\n        'Volume': 'volume',\n        'Close Time': 'close_time',  # \u7d22\u5f15\u5217\u4e5f\u9700\u8981\u6620\u5c04\n        'Quote Asset Volume': 'quote_volume',\n        'Number of Trades': 'count',\n        'Taker Buy Base Volume': 'taker_buy_volume',\n        'Taker Buy Quote Volume': 'taker_buy_quote_volume',\n        'Ignore': 'ignore'\n    }\n\n    # \u91cd\u7f6e\u7d22\u5f15\uff0c\u4f7f Close Time \u6210\u4e3a\u666e\u901a\u5217\n    klines_now = klines_now.reset_index()\n\n    # \u91cd\u547d\u540d\u5217\n    renamed_cols = {}\n    for old_col, new_col in column_mapping.items():\n        if old_col in klines_now.columns:\n            renamed_cols[old_col] = new_col\n\n    klines_now = klines_now.rename(columns=renamed_cols)\n\n    # \u8f6c\u6362\u4e3a Polars DataFrame\n    pl_data = pl.from_pandas(klines_now)\n\n    # \u786e\u4fdd\u8fd4\u56de\u7684 DataFrame \u6709\u6b63\u786e\u7684\u5217\u7c7b\u578b\n    schema = {\n        'open_time': int,\n        'open': pl.Float64,\n        'high': pl.Float64,\n        'low': pl.Float64,\n        'close': pl.Float64,\n        'volume': pl.Float64,\n        'close_time': int,\n        'quote_volume': pl.Float64,\n        'count': pl.Int64,\n        'taker_buy_volume': pl.Float64,\n        'taker_buy_quote_volume': pl.Float64,\n        'ignore': pl.Int64\n    }\n\n    # \u5e94\u7528\u7c7b\u578b\u8f6c\u6362\n    for col, dtype in schema.items():\n        if col in pl_data.columns:\n            if dtype == pl.Datetime and pl_data[col].dtype != pl.Datetime:\n                # \u5982\u679c\u662f\u65e5\u671f\u5217\u4e14\u9700\u8981\u8f6c\u6362\n                if pl_data[col].dtype in (pl.Int64, pl.Float64):\n                    # \u5047\u8bbe\u65f6\u95f4\u6233\u662f\u5fae\u79d2\u7ea7\u7684\n                    pl_data = pl_data.with_columns(\n                        pl.col(col).cast(pl.Int64).cast(pl.Datetime(time_unit=\"us\"))\n                    )\n            else:\n                # \u5176\u4ed6\u5217\u7c7b\u578b\u8f6c\u6362\n                pl_data = pl_data.with_columns(\n                    pl.col(col).cast(dtype)\n                )\n\n\n    return pl_data\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiOffline.order_market","title":"order_market","text":"<pre><code>order_market(\n    symbol: str,\n    side: OrderSideLike,\n    *,\n    quantity: float | None = None,\n    quoteOrderQty: float | None = None,\n    timestamp: datetime | None = None,\n    lock_rate: float = 1.0,\n    **kwargs,\n) -&gt; OrderResponseFull\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>@override\ndef order_market(\n    self,\n    symbol: str,\n    side: OrderSideLike,\n    *,\n    quantity: float | None = None,\n    quoteOrderQty: float | None = None,\n    timestamp: datetime | None = None,\n    lock_rate: float = 1.0,  # \u4fdd\u8bc1\u91d1\u500d\u6570\u53c2\u6570\uff0c\u9ed8\u8ba4\u4e3a1\u500d\n    **kwargs,\n) -&gt; OrderResponseFull:\n    now = self.now_index\n    transaction_fee = 0.001  # \u4ea4\u6613\u8d39\u7528\u4e3a0.1%\n\n    try:\n        # \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u70b9\u7684\u4ef7\u683c\u6570\u636e\n        symbol_key = f\"{symbol}_klines_1m\"\n\n        if not self.library.has_symbol(symbol_key):\n            raise ValueError(f\"Symbol {symbol_key} not found in library\")\n\n        # \u8bfb\u53d6\u6570\u636e\n        df = self.library.read(symbol_key).data\n\n        # \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u6233\u5bf9\u5e94\u7684\u884c\n        price_row = df[df.index == now]\n\n        if price_row.empty:\n            raise ValueError(f\"No price data found for timestamp {now}\")\n\n        # \u83b7\u53d6\u6536\u76d8\u4ef7\u5e76\u786e\u4fdd\u662ffloat\u7c7b\u578b\n        try:\n            price = float(price_row['Close'].iloc[0])\n        except (ValueError, TypeError):\n            # \u5982\u679c\u8f6c\u6362\u5931\u8d25\uff0c\u5c1d\u8bd5\u5176\u4ed6\u5217\u540d\uff08\u5927\u5c0f\u5199\u4e0d\u540c\uff09\n            try:\n                price = float(price_row['close'].iloc[0])\n            except (ValueError, TypeError, KeyError):\n                raise ValueError(f\"\u65e0\u6cd5\u83b7\u53d6\u6709\u6548\u7684\u6536\u76d8\u4ef7\u683c\u6570\u636e (\u65f6\u95f4\u6233: {now})\")\n\n        print(f\"\u6267\u884c\u5e02\u4ef7\u5355: {symbol}, \u65b9\u5411: {side}, \u4ef7\u683c: {price}, \u6570\u91cf: {quantity}\")\n\n        # \u4ea4\u6613\u7684\u57fa\u7840\u8d44\u4ea7\u548c\u62a5\u4ef7\u8d44\u4ea7\n        base_asset = symbol.replace(\"USDT\", \"\")\n        quote_asset = \"USDT\"\n\n        # \u8f85\u52a9\u51fd\u6570\uff1a\u83b7\u53d6\u8d44\u4ea7\u4f59\u989d\n        def get_asset_balance(asset, balance_type=\"free\"):\n            for balance in self.monitor_account[\"balances\"]:\n                if balance[\"asset\"] == asset:\n                    return float(balance[balance_type])\n            return 0.0\n\n        # \u8f85\u52a9\u51fd\u6570\uff1a\u66f4\u65b0\u8d44\u4ea7\u4f59\u989d\n        def update_asset_balance(asset, amount, balance_type=\"free\"):\n            for balance in self.monitor_account[\"balances\"]:\n                if balance[\"asset\"] == asset:\n                    current_amount = float(balance[balance_type])\n                    balance[balance_type] = str(current_amount + amount)\n                    return\n\n            # \u5982\u679c\u8d44\u4ea7\u4e0d\u5b58\u5728\uff0c\u6dfb\u52a0\u65b0\u8d44\u4ea7\n            new_balance = {\n                \"asset\": asset,\n                \"free\": \"0.00000000\",\n                \"locked\": \"0.00000000\"\n            }\n            new_balance[balance_type] = str(amount)\n            self.monitor_account[\"balances\"].append(new_balance)\n\n        # \u4e70\u5165\u903b\u8f91\n        if side == \"BUY\":\n            if quantity is None:\n                raise ValueError(\"Must provide quantity for BUY order\")\n\n            # \u8ba1\u7b97\u6240\u9700\u7684USDT\u91d1\u989d\uff08\u5305\u542b\u624b\u7eed\u8d39\uff09\n            quote_amount = quantity * price\n            fee_amount = quote_amount * transaction_fee\n            total_cost = quote_amount + fee_amount\n\n            # \u68c0\u67e5\u4f59\u989d\u662f\u5426\u8db3\u591f\n            usdt_free = get_asset_balance(quote_asset)\n            if usdt_free &lt; total_cost:\n                raise ValueError(f\"Insufficient {quote_asset} balance: {usdt_free} &lt; {total_cost}\")\n\n            # \u76f4\u63a5\u6263\u9664USDT\u4f59\u989d\n            update_asset_balance(quote_asset, -total_cost)\n            # \u589e\u52a0\u57fa\u7840\u8d44\u4ea7\n            update_asset_balance(base_asset, quantity)\n\n            print(f\"\u4e70\u5165 {quantity} {base_asset} \u82b1\u8d39 {total_cost} {quote_asset} (\u542b\u624b\u7eed\u8d39 {fee_amount})\")\n\n        # \u5356\u51fa\u903b\u8f91\n        elif side == \"SELL\":\n            if quantity is None:\n                raise ValueError(\"Must provide quantity for SELL order\")\n\n            # \u68c0\u67e5\u57fa\u7840\u8d44\u4ea7\u4f59\u989d\n            base_free = get_asset_balance(base_asset)\n\n            # \u8ba1\u7b97\u5356\u51fa\u7684USDT\u91d1\u989d\n            quote_amount = quantity * price\n            fee_amount = quote_amount * transaction_fee\n            net_received = quote_amount - fee_amount\n\n            # \u60c5\u51b51: \u6709\u8db3\u591f\u4f59\u989d\u76f4\u63a5\u5356\u51fa\n            if base_free &gt;= quantity:\n                update_asset_balance(base_asset, -quantity)\n                update_asset_balance(quote_asset, net_received)\n                print(f\"\u5356\u51fa {quantity} {base_asset} \u83b7\u5f97 {net_received} {quote_asset} (\u6263\u9664\u624b\u7eed\u8d39 {fee_amount})\")\n\n            # \u60c5\u51b52: \u4f59\u989d\u4e0d\u8db3\uff0c\u5148\u5356\u51fa\u5df2\u6709\u4f59\u989d\uff0c\u518d\u505a\u7a7a\u5269\u4f59\u90e8\u5206\n            else:\n                # \u5206\u4e24\u90e8\u5206\u5904\u7406\n                # 1. \u5148\u5356\u51fa\u5df2\u6709\u7684\u4f59\u989d\n                if base_free &gt; 0:\n                    partial_quote_amount = base_free * price\n                    partial_fee = partial_quote_amount * transaction_fee\n                    partial_net = partial_quote_amount - partial_fee\n\n                    update_asset_balance(base_asset, -base_free)\n                    update_asset_balance(quote_asset, partial_net)\n                    print(f\"\u5356\u51fa\u53ef\u7528\u4f59\u989d {base_free} {base_asset} \u83b7\u5f97 {partial_net} {quote_asset}\")\n\n                # 2. \u5269\u4f59\u90e8\u5206\u4f7f\u7528\u4fdd\u8bc1\u91d1\u505a\u7a7a\n                remaining_quantity = quantity - base_free\n                short_quote_amount = remaining_quantity * price\n                short_fee = short_quote_amount * transaction_fee\n\n                # \u8ba1\u7b97\u9700\u8981\u9501\u5b9a\u7684\u4fdd\u8bc1\u91d1 (\u4f7f\u7528lock_rate\u500d\u4fdd\u8bc1\u91d1)\n                required_margin = short_quote_amount / lock_rate\n\n                # \u68c0\u67e5USDT\u4f59\u989d\u662f\u5426\u8db3\u591f\u4f5c\u4e3a\u4fdd\u8bc1\u91d1\n                if get_asset_balance(quote_asset) &lt; required_margin:\n                    raise ValueError(f\"Insufficient {quote_asset} for margin: {get_asset_balance(quote_asset)} &lt; {required_margin}\")\n\n                # \u9501\u5b9a\u4fdd\u8bc1\u91d1 (\u4ecefree\u79fb\u5230locked)\n                update_asset_balance(quote_asset, -required_margin)\n                update_asset_balance(quote_asset, required_margin, \"locked\")\n\n                # \u521b\u5efa\u505a\u7a7a\u5934\u5bf8\u8bb0\u5f55 (\u53ef\u4ee5\u6dfb\u52a0\u5230\u76d1\u63a7\u8d26\u6237\u7684\u989d\u5916\u5b57\u6bb5\u4e2d)\n                # \u8fd9\u91cc\u7b80\u5316\u5904\u7406\uff0c\u53ea\u5728base_asset\u4e2d\u8bb0\u5f55\u8d1f\u6570\u4f59\u989d\n                update_asset_balance(base_asset, -remaining_quantity)\n                update_asset_balance(quote_asset, short_quote_amount - short_fee)\n\n                print(f\"\u505a\u7a7a {remaining_quantity} {base_asset} \u4f7f\u7528\u4fdd\u8bc1\u91d1 {required_margin} {quote_asset} (\u6760\u6746\u7387: {lock_rate})\")\n                print(f\"\u505a\u7a7a\u83b7\u5f97 {short_quote_amount - short_fee} {quote_asset} (\u6263\u9664\u624b\u7eed\u8d39 {short_fee})\")\n\n        # \u521b\u5efa\u8ba2\u5355\u54cd\u5e94\u5bf9\u8c61\n        from qoc.api.typing import OrderResponseFull, OrderResponseFill, OrderType, OrderSide\n        import datetime\n        import uuid\n\n        # \u521b\u5efa\u4e00\u4e2a\u552f\u4e00\u7684\u5ba2\u6237\u7aef\u8ba2\u5355ID\n        client_order_id = f\"offline_{uuid.uuid4().hex[:16]}\"\n\n        # \u521b\u5efafills\u5217\u8868 (\u6210\u4ea4\u660e\u7ec6)\n        fills = [\n            OrderResponseFill(\n                price=price,\n                qty=quantity,\n                commission=fee_amount,  # \u624b\u7eed\u8d39\n                commissionasset=quote_asset,  # \u624b\u7eed\u8d39\u8d44\u4ea7\n                tradeid=int(now % 1000000)  # \u4f7f\u7528\u65f6\u95f4\u6233\u90e8\u5206\u4f5c\u4e3a\u4ea4\u6613ID\n            )\n        ]\n\n        # \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u4f5c\u4e3a\u4ea4\u6613\u65f6\u95f4\n        current_time = datetime.datetime.fromtimestamp(now / 1000000)\n\n        # \u8f6c\u6362side\u5b57\u7b26\u4e32\u4e3aOrderSide\u679a\u4e3e\n        order_side = OrderSide(side)\n\n        # \u6784\u5efa\u5e76\u8fd4\u56deOrderResponseFull\u5bf9\u8c61\n        return OrderResponseFull(\n            symbol=symbol,\n            clientorderid=client_order_id,\n            transacttime=current_time,\n            price=price,\n            origqty=quantity if quantity is not None else 0.0,\n            executedqty=quantity if quantity is not None else 0.0,\n            origquoteorderqty=quoteOrderQty if quoteOrderQty is not None else 0.0,\n            cummulativequoteqty=quote_amount if 'quote_amount' in locals() else 0.0,  # \u603b\u4ef7\u503c\n            type=OrderType.MARKET,  # \u5e02\u4ef7\u5355\n            side=order_side,\n            workingtime=current_time,\n            fills=fills,\n            # \u6dfb\u52a0\u6269\u5c55\u5c5e\u6027 (\u5982\u679c\u652f\u6301\u7684\u8bdd)\n            # lockRate is not a valid parameter, removing it\n            # isShort is not a valid parameter, removing it\n        )\n\n    except Exception as e:\n        print(f\"\u6267\u884c\u5e02\u4ef7\u5355\u51fa\u9519: {e}\")\n        raise\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ApiOffline.step","title":"step","text":"<pre><code>step() -&gt; bool\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>def step(self) -&gt; bool:\n    if self.now_index + self.interval &lt;= self.timestamps[-1]:\n        self.now_index += self.interval\n        print(f\"\u65f6\u95f4\u63a8\u8fdb\u5230: {self.now_index} \")\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfo","title":"ExchangeInfo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> <ul> <li> <code>symbols</code>               (<code>list[ExchangeInfoSymbol]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>get_symbol</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>model_config</code>           \u2013            </li> <li> <code>symbols</code>               (<code>list[ExchangeInfoSymbol]</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfo.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"allow\", alias_generator=to_camel\n)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfo.symbols","title":"symbols  <code>instance-attribute</code>","text":"<pre><code>symbols: list[ExchangeInfoSymbol]\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfo.get_symbol","title":"get_symbol","text":"<pre><code>get_symbol(symbol: str) -&gt; ExchangeInfoSymbol\n</code></pre> Source code in <code>src/qoc/api/binance/_exchange_info.py</code> <pre><code>def get_symbol(self, symbol: str) -&gt; ExchangeInfoSymbol:\n    for s in self.symbols:\n        if s.symbol == symbol:\n            return s\n    raise KeyError(symbol)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfoSymbol","title":"ExchangeInfoSymbol","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> <ul> <li> <code>symbol</code>               (<code>str</code>)           \u2013            </li> <li> <code>base_asset</code>               (<code>str</code>)           \u2013            </li> <li> <code>quote_asset</code>               (<code>str</code>)           \u2013            </li> <li> <code>filters</code>               (<code>list[TypeAliasType]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>get_filter</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>base_asset</code>               (<code>str</code>)           \u2013            </li> <li> <code>filters</code>               (<code>list[Filter]</code>)           \u2013            </li> <li> <code>lot_size</code>               (<code>LotSize | None</code>)           \u2013            </li> <li> <code>min_notional</code>               (<code>MinNotional | None</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> <li> <code>notional</code>               (<code>Notional | None</code>)           \u2013            </li> <li> <code>quote_asset</code>               (<code>str</code>)           \u2013            </li> <li> <code>symbol</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfoSymbol.base_asset","title":"base_asset  <code>instance-attribute</code>","text":"<pre><code>base_asset: str\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfoSymbol.filters","title":"filters  <code>instance-attribute</code>","text":"<pre><code>filters: list[Filter]\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfoSymbol.lot_size","title":"lot_size  <code>property</code>","text":"<pre><code>lot_size: LotSize | None\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfoSymbol.min_notional","title":"min_notional  <code>property</code>","text":"<pre><code>min_notional: MinNotional | None\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfoSymbol.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"allow\", alias_generator=to_camel\n)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfoSymbol.notional","title":"notional  <code>property</code>","text":"<pre><code>notional: Notional | None\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfoSymbol.quote_asset","title":"quote_asset  <code>instance-attribute</code>","text":"<pre><code>quote_asset: str\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfoSymbol.symbol","title":"symbol  <code>instance-attribute</code>","text":"<pre><code>symbol: str\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.ExchangeInfoSymbol.get_filter","title":"get_filter","text":"<pre><code>get_filter(filter_type: FilterTypeLike) -&gt; Filter | None\n</code></pre> Source code in <code>src/qoc/api/binance/_exchange_info.py</code> <pre><code>def get_filter(self, filter_type: FilterTypeLike) -&gt; Filter | None:\n    for f in self.filters:\n        if f.filter_type == filter_type:\n            return f\n    return None\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFill","title":"OrderResponseFill","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> <ul> <li> <code>price</code>               (<code>float</code>)           \u2013            </li> <li> <code>qty</code>               (<code>float</code>)           \u2013            </li> <li> <code>commission</code>               (<code>float</code>)           \u2013            </li> <li> <code>commissionasset</code>               (<code>str</code>)           \u2013            </li> <li> <code>tradeid</code>               (<code>int</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>commission</code>               (<code>float</code>)           \u2013            </li> <li> <code>commissionasset</code>               (<code>str</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> <li> <code>price</code>               (<code>float</code>)           \u2013            </li> <li> <code>qty</code>               (<code>float</code>)           \u2013            </li> <li> <code>tradeid</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFill.commission","title":"commission  <code>instance-attribute</code>","text":"<pre><code>commission: float\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFill.commissionasset","title":"commissionasset  <code>instance-attribute</code>","text":"<pre><code>commissionasset: str\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFill.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"allow\", alias_generator=to_camel\n)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFill.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: float\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFill.qty","title":"qty  <code>instance-attribute</code>","text":"<pre><code>qty: float\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFill.tradeid","title":"tradeid  <code>instance-attribute</code>","text":"<pre><code>tradeid: int\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull","title":"OrderResponseFull","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> <ul> <li> <code>symbol</code>               (<code>str</code>)           \u2013            </li> <li> <code>clientorderid</code>               (<code>str</code>)           \u2013            </li> <li> <code>transacttime</code>               (<code>datetime</code>)           \u2013            </li> <li> <code>price</code>               (<code>float</code>)           \u2013            </li> <li> <code>origqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>executedqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>origquoteorderqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>cummulativequoteqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>type</code>               (<code>OrderType</code>)           \u2013            </li> <li> <code>side</code>               (<code>OrderSide</code>)           \u2013            </li> <li> <code>workingtime</code>               (<code>datetime</code>)           \u2013            </li> <li> <code>fills</code>               (<code>list[OrderResponseFill]</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>clientorderid</code>               (<code>str</code>)           \u2013            </li> <li> <code>cummulativequoteqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>executedqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>fills</code>               (<code>list[OrderResponseFill]</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> <li> <code>origqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>origquoteorderqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>price</code>               (<code>float</code>)           \u2013            </li> <li> <code>side</code>               (<code>OrderSide</code>)           \u2013            </li> <li> <code>symbol</code>               (<code>str</code>)           \u2013            </li> <li> <code>transacttime</code>               (<code>datetime</code>)           \u2013            </li> <li> <code>type</code>               (<code>OrderType</code>)           \u2013            </li> <li> <code>workingtime</code>               (<code>datetime</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull.clientorderid","title":"clientorderid  <code>instance-attribute</code>","text":"<pre><code>clientorderid: str\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull.cummulativequoteqty","title":"cummulativequoteqty  <code>instance-attribute</code>","text":"<pre><code>cummulativequoteqty: float\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull.executedqty","title":"executedqty  <code>instance-attribute</code>","text":"<pre><code>executedqty: float\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull.fills","title":"fills  <code>instance-attribute</code>","text":"<pre><code>fills: list[OrderResponseFill]\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"allow\", alias_generator=to_camel\n)\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull.origqty","title":"origqty  <code>instance-attribute</code>","text":"<pre><code>origqty: float\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull.origquoteorderqty","title":"origquoteorderqty  <code>instance-attribute</code>","text":"<pre><code>origquoteorderqty: float\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: float\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull.side","title":"side  <code>instance-attribute</code>","text":"<pre><code>side: OrderSide\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull.symbol","title":"symbol  <code>instance-attribute</code>","text":"<pre><code>symbol: str\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull.transacttime","title":"transacttime  <code>instance-attribute</code>","text":"<pre><code>transacttime: datetime\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: OrderType = Field(alias='type')\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderResponseFull.workingtime","title":"workingtime  <code>instance-attribute</code>","text":"<pre><code>workingtime: datetime\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderSide","title":"OrderSide","text":"<p>               Bases: <code>CaseInsensitiveEnum</code></p> <p>Attributes:</p> <ul> <li> <code>BUY</code>           \u2013            </li> <li> <code>SELL</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/api/#qoc.api.OrderSide.BUY","title":"BUY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUY = auto()\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderSide.SELL","title":"SELL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SELL = auto()\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderType","title":"OrderType","text":"<p>               Bases: <code>CaseInsensitiveEnum</code></p> <p>Attributes:</p> <ul> <li> <code>LIMIT</code>           \u2013            </li> <li> <code>LIMIT_MAKER</code>           \u2013            </li> <li> <code>MARKET</code>           \u2013            </li> <li> <code>STOP_LOSS</code>           \u2013            </li> <li> <code>STOP_LOSS_LIMIT</code>           \u2013            </li> <li> <code>TAKE_PROFIT</code>           \u2013            </li> <li> <code>TAKE_PROFIT_LIMIT</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/api/#qoc.api.OrderType.LIMIT","title":"LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIMIT = auto()\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderType.LIMIT_MAKER","title":"LIMIT_MAKER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIMIT_MAKER = auto()\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderType.MARKET","title":"MARKET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MARKET = auto()\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderType.STOP_LOSS","title":"STOP_LOSS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOP_LOSS = auto()\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderType.STOP_LOSS_LIMIT","title":"STOP_LOSS_LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOP_LOSS_LIMIT = auto()\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderType.TAKE_PROFIT","title":"TAKE_PROFIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAKE_PROFIT = auto()\n</code></pre>"},{"location":"reference/qoc/api/#qoc.api.OrderType.TAKE_PROFIT_LIMIT","title":"TAKE_PROFIT_LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAKE_PROFIT_LIMIT = auto()\n</code></pre>"},{"location":"reference/qoc/api/binance/","title":"qoc.api.binance","text":""},{"location":"reference/qoc/api/binance/#qoc.api.binance","title":"qoc.api.binance","text":"<p>Type Aliases:</p> <ul> <li> <code>Filter</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>ApiBinance</code>           \u2013            </li> <li> <code>ExchangeInfo</code>           \u2013            </li> <li> <code>ExchangeInfoSymbol</code>           \u2013            </li> <li> <code>FilterExtra</code>           \u2013            </li> <li> <code>FilterType</code>           \u2013            </li> <li> <code>LotSize</code>           \u2013            </li> <li> <code>TimeUnit</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.Filter","title":"Filter","text":"<pre><code>Filter = (\n    Annotated[\n        LotSize | MinNotional,\n        Field(discriminator=filter_type),\n    ]\n    | FilterExtra\n)\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ApiBinance","title":"ApiBinance","text":"<p>Parameters:</p> <ul> <li> <code>client</code>               (<code>Spot</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>account</code>             \u2013              </li> <li> <code>create</code>             \u2013              </li> <li> <code>exchange_info</code>             \u2013              </li> <li> <code>klines</code>             \u2013              </li> <li> <code>order</code>             \u2013              </li> <li> <code>order_market</code>             \u2013              </li> <li> <code>ping</code>             \u2013              </li> <li> <code>step</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>client</code>               (<code>Spot</code>)           \u2013            </li> <li> <code>timeunit</code>               (<code>TimeUnit</code>)           \u2013            <p>.</p> </li> </ul>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ApiBinance.client","title":"client  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client: Spot = field()\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ApiBinance.timeunit","title":"timeunit  <code>property</code>","text":"<pre><code>timeunit: TimeUnit\n</code></pre> <p>.</p> <p>All time and timestamp related fields in the JSON responses are in milliseconds by default.</p> References <ol> <li>https://developers.binance.com/docs/binance-spot-api-docs/testnet/rest-api/general-api-information</li> </ol>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ApiBinance.account","title":"account","text":"<pre><code>account(**kwargs) -&gt; Account\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def account(self, **kwargs) -&gt; Account:\n    raw: dict = self.client.account(**kwargs)\n    return Account.model_validate(raw)\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ApiBinance.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    api_key: str | None = None,\n    api_secret: str | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>@classmethod\ndef create(\n    cls, api_key: str | None = None, api_secret: str | None = None, **kwargs\n) -&gt; Self:\n    if api_key is None:\n        api_key = env.str(\"BINANCE_API_KEY\", None)\n    if api_secret is None:\n        api_secret = env.str(\"BINANCE_API_SECRET\", None)\n    if not kwargs.get(\"base_url\") and (\n        base_url := env.str(\"BINANCE_BASE_URL\", None)\n    ):\n        kwargs[\"base_url\"] = base_url\n    client = binance.spot.Spot(api_key=api_key, api_secret=api_secret, **kwargs)\n    return cls(client=client)\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ApiBinance.exchange_info","title":"exchange_info","text":"<pre><code>exchange_info(\n    symbol: str | None = None,\n    symbols: list[str] | None = None,\n    permissions: list[str] | None = None,\n) -&gt; ExchangeInfo\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def exchange_info(\n    self,\n    symbol: str | None = None,\n    symbols: list[str] | None = None,\n    permissions: list[str] | None = None,\n) -&gt; ExchangeInfo:\n    data = self.client.exchange_info(\n        symbol=symbol,  # pyright: ignore[reportArgumentType]\n        symbols=symbols,  # pyright: ignore[reportArgumentType]\n        permissions=permissions,  # pyright: ignore[reportArgumentType]\n    )\n    return ExchangeInfo.model_validate(data)\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ApiBinance.klines","title":"klines","text":"<pre><code>klines(\n    symbol: str,\n    interval: Interval,\n    *,\n    start_time: datetime | None = None,\n    **kwargs,\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def klines(\n    self,\n    symbol: str,\n    interval: Interval,\n    *,\n    start_time: datetime.datetime | None = None,\n    **kwargs,\n) -&gt; pl.DataFrame:\n    if start_time:\n        kwargs[\"startTime\"] = self.timeunit.from_datetime(start_time)\n    response: list[list[int | str]] = self.client.klines(\n        symbol=symbol, interval=interval, **kwargs\n    )\n    data: pl.DataFrame = pl.from_records(\n        response,\n        schema=[\n            (\n                \"open_time\",\n                pl.Datetime(time_unit=self.timeunit.to_polars),\n            ),  # Kline open time\n            (\"open\", pl.Float64),  # Open price\n            (\"high\", pl.Float64),  # High price\n            (\"low\", pl.Float64),  # Low price\n            (\"close\", pl.Float64),  # Close price\n            (\"volume\", pl.Float64),  # Volume\n            (\n                \"close_time\",\n                pl.Datetime(time_unit=self.timeunit.to_polars),\n            ),  # Kline Close time\n            (\"quote_volume\", pl.Float64),  # Quote asset volume\n            (\"count\", pl.Int64),  # Number of trades\n            (\"taker_buy_volume\", pl.Float64),  # Taker buy base asset volume\n            (\"taker_buy_quote_volume\", pl.Float64),  # Taker buy quote asset volume\n            (\"ignore\", pl.Int64),  # Unused field, ignore.\n        ],\n        orient=\"row\",\n    )\n\n\n    # \u5c06 Datetime \u65f6\u95f4\u6233\u8f6c\u6362\u4e3a\u6574\u6570\u5fae\u79d2\u65f6\u95f4\u6233\n    time_unit_multiplier = {\n        \"ns\": 0.001,  # \u7eb3\u79d2\u8f6c\u5fae\u79d2\u9700\u8981\u9664\u4ee5 1000\n        \"us\": 1,      # \u5fae\u79d2\u4fdd\u6301\u4e0d\u53d8\n        \"ms\": 1000,   # \u6beb\u79d2\u8f6c\u5fae\u79d2\u9700\u8981\u4e58\u4ee5 1000\n        \"s\": 1000000, # \u79d2\u8f6c\u5fae\u79d2\u9700\u8981\u4e58\u4ee5 1000000\n    }[self.timeunit.to_polars]\n\n    # \u8f6c\u6362\u65f6\u95f4\u5217\u4e3a\u6574\u6570\u5fae\u79d2\u65f6\u95f4\u6233\n    data = data.with_columns([\n        pl.col(\"open_time\").dt.epoch(\"us\").alias(\"open_time\"),\n        pl.col(\"close_time\").dt.epoch(\"us\").alias(\"close_time\")\n    ])\n    return data\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ApiBinance.order","title":"order","text":"<pre><code>order(\n    symbol: str,\n    side: OrderSideLike,\n    type_: OrderTypeLike,\n    **kwargs,\n) -&gt; OrderResponseFull\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def order(\n    self, symbol: str, side: OrderSideLike, type_: OrderTypeLike, **kwargs\n) -&gt; OrderResponseFull:\n    side = OrderSide(side)\n    type_ = OrderType(type_)\n    logger.info(\n        \"New Order &gt; symbol: {}, side: {}, type: {}, {}\",\n        symbol,\n        side,\n        type_,\n        kwargs,\n    )\n    raw: dict = self.client.new_order(\n        symbol=symbol, side=side, type=type_, **kwargs\n    )\n    response: OrderResponseFull = OrderResponseFull.model_validate(raw)\n    logger.info(response)\n    return response\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ApiBinance.order_market","title":"order_market","text":"<pre><code>order_market(\n    symbol: str,\n    side: OrderSideLike,\n    *,\n    quantity: float | None = None,\n    quoteOrderQty: float | None = None,\n    **kwargs,\n) -&gt; OrderResponseFull\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def order_market(\n    self,\n    symbol: str,\n    side: OrderSideLike,\n    *,\n    quantity: float | None = None,\n    quoteOrderQty: float | None = None,\n    **kwargs,\n) -&gt; OrderResponseFull:\n    if quantity is not None:\n        kwargs[\"quantity\"] = f\"{quantity:f}\"\n    if quoteOrderQty is not None:\n        kwargs[\"quoteOrderQty\"] = f\"{quoteOrderQty:f}\"\n    return self.order(symbol, side, OrderType.MARKET, **kwargs)\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ApiBinance.ping","title":"ping","text":"<pre><code>ping() -&gt; None\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def ping(self) -&gt; None:\n    self.client.ping()\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ApiBinance.step","title":"step","text":"<pre><code>step() -&gt; bool\n</code></pre> Source code in <code>src/qoc/api/binance/_main.py</code> <pre><code>def step(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfo","title":"ExchangeInfo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> <ul> <li> <code>symbols</code>               (<code>list[ExchangeInfoSymbol]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>get_symbol</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>model_config</code>           \u2013            </li> <li> <code>symbols</code>               (<code>list[ExchangeInfoSymbol]</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfo.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"allow\", alias_generator=to_camel\n)\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfo.symbols","title":"symbols  <code>instance-attribute</code>","text":"<pre><code>symbols: list[ExchangeInfoSymbol]\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfo.get_symbol","title":"get_symbol","text":"<pre><code>get_symbol(symbol: str) -&gt; ExchangeInfoSymbol\n</code></pre> Source code in <code>src/qoc/api/binance/_exchange_info.py</code> <pre><code>def get_symbol(self, symbol: str) -&gt; ExchangeInfoSymbol:\n    for s in self.symbols:\n        if s.symbol == symbol:\n            return s\n    raise KeyError(symbol)\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfoSymbol","title":"ExchangeInfoSymbol","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> <ul> <li> <code>symbol</code>               (<code>str</code>)           \u2013            </li> <li> <code>base_asset</code>               (<code>str</code>)           \u2013            </li> <li> <code>quote_asset</code>               (<code>str</code>)           \u2013            </li> <li> <code>filters</code>               (<code>list[TypeAliasType]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>get_filter</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>base_asset</code>               (<code>str</code>)           \u2013            </li> <li> <code>filters</code>               (<code>list[Filter]</code>)           \u2013            </li> <li> <code>lot_size</code>               (<code>LotSize | None</code>)           \u2013            </li> <li> <code>min_notional</code>               (<code>MinNotional | None</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> <li> <code>notional</code>               (<code>Notional | None</code>)           \u2013            </li> <li> <code>quote_asset</code>               (<code>str</code>)           \u2013            </li> <li> <code>symbol</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfoSymbol.base_asset","title":"base_asset  <code>instance-attribute</code>","text":"<pre><code>base_asset: str\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfoSymbol.filters","title":"filters  <code>instance-attribute</code>","text":"<pre><code>filters: list[Filter]\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfoSymbol.lot_size","title":"lot_size  <code>property</code>","text":"<pre><code>lot_size: LotSize | None\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfoSymbol.min_notional","title":"min_notional  <code>property</code>","text":"<pre><code>min_notional: MinNotional | None\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfoSymbol.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"allow\", alias_generator=to_camel\n)\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfoSymbol.notional","title":"notional  <code>property</code>","text":"<pre><code>notional: Notional | None\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfoSymbol.quote_asset","title":"quote_asset  <code>instance-attribute</code>","text":"<pre><code>quote_asset: str\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfoSymbol.symbol","title":"symbol  <code>instance-attribute</code>","text":"<pre><code>symbol: str\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.ExchangeInfoSymbol.get_filter","title":"get_filter","text":"<pre><code>get_filter(filter_type: FilterTypeLike) -&gt; Filter | None\n</code></pre> Source code in <code>src/qoc/api/binance/_exchange_info.py</code> <pre><code>def get_filter(self, filter_type: FilterTypeLike) -&gt; Filter | None:\n    for f in self.filters:\n        if f.filter_type == filter_type:\n            return f\n    return None\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.FilterExtra","title":"FilterExtra","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> <ul> <li> <code>filter_type</code>               (<code>str</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>filter_type</code>               (<code>str</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.FilterExtra.filter_type","title":"filter_type  <code>instance-attribute</code>","text":"<pre><code>filter_type: str\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.FilterExtra.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"allow\", alias_generator=to_camel\n)\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.FilterType","title":"FilterType","text":"<p>               Bases: <code>CaseInsensitiveEnum</code></p> <p>Attributes:</p> <ul> <li> <code>LOT_SIZE</code>           \u2013            </li> <li> <code>MIN_NOTIONAL</code>           \u2013            </li> <li> <code>NOTIONAL</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.FilterType.LOT_SIZE","title":"LOT_SIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOT_SIZE = auto()\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.FilterType.MIN_NOTIONAL","title":"MIN_NOTIONAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MIN_NOTIONAL = auto()\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.FilterType.NOTIONAL","title":"NOTIONAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOTIONAL = auto()\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.LotSize","title":"LotSize","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> <ul> <li> <code>filter_type</code>               (<code>Literal[&lt;FilterType.LOT_SIZE: 'LOT_SIZE'&gt;]</code>, default:                   <code>&lt;FilterType.LOT_SIZE: 'LOT_SIZE'&gt;</code> )           \u2013            </li> <li> <code>min_qty</code>               (<code>float</code>)           \u2013            </li> <li> <code>max_qty</code>               (<code>float</code>)           \u2013            </li> <li> <code>step_size</code>               (<code>float</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>filter_type</code>               (<code>Literal[LOT_SIZE]</code>)           \u2013            </li> <li> <code>max_qty</code>               (<code>float</code>)           \u2013            </li> <li> <code>min_qty</code>               (<code>float</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> <li> <code>step_size</code>               (<code>float</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.LotSize.filter_type","title":"filter_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filter_type: Literal[LOT_SIZE] = LOT_SIZE\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.LotSize.max_qty","title":"max_qty  <code>instance-attribute</code>","text":"<pre><code>max_qty: float\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.LotSize.min_qty","title":"min_qty  <code>instance-attribute</code>","text":"<pre><code>min_qty: float\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.LotSize.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"allow\", alias_generator=to_camel\n)\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.LotSize.step_size","title":"step_size  <code>instance-attribute</code>","text":"<pre><code>step_size: float\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.TimeUnit","title":"TimeUnit","text":"<p>               Bases: <code>StrEnum</code></p> <p>Methods:</p> <ul> <li> <code>from_datetime</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>MICROSECOND</code>           \u2013            </li> <li> <code>MILLISECOND</code>           \u2013            </li> <li> <code>to_polars</code>               (<code>TimeUnitPolars</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.TimeUnit.MICROSECOND","title":"MICROSECOND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MICROSECOND = auto()\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.TimeUnit.MILLISECOND","title":"MILLISECOND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MILLISECOND = auto()\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.TimeUnit.to_polars","title":"to_polars  <code>property</code>","text":"<pre><code>to_polars: TimeUnitPolars\n</code></pre>"},{"location":"reference/qoc/api/binance/#qoc.api.binance.TimeUnit.from_datetime","title":"from_datetime","text":"<pre><code>from_datetime(datetime: datetime) -&gt; int\n</code></pre> Source code in <code>src/qoc/api/binance/_typing.py</code> <pre><code>def from_datetime(self, datetime: datetime.datetime) -&gt; int:\n    return int(datetime.timestamp() * TIME_UNIT_FROM_SECONDS[self])\n</code></pre>"},{"location":"reference/qoc/api/offline/","title":"qoc.api.offline","text":""},{"location":"reference/qoc/api/offline/#qoc.api.offline","title":"qoc.api.offline","text":"<p>Classes:</p> <ul> <li> <code>ApiOffline</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/api/offline/#qoc.api.offline.ApiOffline","title":"ApiOffline","text":"<p>               Bases: <code>TradingApi</code></p> <p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>monitor_account</code>               (<code>dict</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> <li> <code>timestamps</code>               (<code>list[int]</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> </li> <li> <code>now_index</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            </li> <li> <code>interval</code>               (<code>int</code>, default:                   <code>60000000</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>account</code>             \u2013              <p>\u8fd4\u56de\u5f53\u524d\u6a21\u62df\u8d26\u6237\u4fe1\u606f</p> </li> <li> <code>create</code>             \u2013              </li> <li> <code>exchange_info</code>             \u2013              </li> <li> <code>klines</code>             \u2013              </li> <li> <code>order_market</code>             \u2013              </li> <li> <code>step</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>interval</code>               (<code>int</code>)           \u2013            </li> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>monitor_account</code>               (<code>dict</code>)           \u2013            </li> <li> <code>now_index</code>               (<code>int</code>)           \u2013            </li> <li> <code>timestamps</code>               (<code>list[int]</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/api/offline/#qoc.api.offline.ApiOffline.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interval: int = field(default=60 * 1000000)\n</code></pre>"},{"location":"reference/qoc/api/offline/#qoc.api.offline.ApiOffline.library","title":"library  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library: Library = field()\n</code></pre>"},{"location":"reference/qoc/api/offline/#qoc.api.offline.ApiOffline.monitor_account","title":"monitor_account  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>monitor_account: dict = field(factory=dict)\n</code></pre>"},{"location":"reference/qoc/api/offline/#qoc.api.offline.ApiOffline.now_index","title":"now_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>now_index: int = field(default=0)\n</code></pre>"},{"location":"reference/qoc/api/offline/#qoc.api.offline.ApiOffline.timestamps","title":"timestamps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestamps: list[int] = field(factory=list)\n</code></pre>"},{"location":"reference/qoc/api/offline/#qoc.api.offline.ApiOffline.account","title":"account","text":"<pre><code>account(**kwargs) -&gt; Account\n</code></pre> <p>\u8fd4\u56de\u5f53\u524d\u6a21\u62df\u8d26\u6237\u4fe1\u606f</p> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>@override\ndef account(self, **kwargs) -&gt; Account:\n    \"\"\"\u8fd4\u56de\u5f53\u524d\u6a21\u62df\u8d26\u6237\u4fe1\u606f\"\"\"\n    # \u76f4\u63a5\u4f7f\u7528\u5b58\u50a8\u7684\u8d26\u6237\u6570\u636e\u7ed3\u6784\n    from qoc.api.typing import Account\n\n    # \u8fd4\u56de\u9a8c\u8bc1\u8fc7\u7684\u8d26\u6237\u5bf9\u8c61\n    return Account.model_validate(self.monitor_account)\n</code></pre>"},{"location":"reference/qoc/api/offline/#qoc.api.offline.ApiOffline.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    library: Library,\n    symbols: list[str],\n    start_date: str,\n    end_date: str,\n) -&gt; Self\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>@classmethod\ndef create(cls, library: adb.library.Library, symbols: list[str], start_date: str, end_date: str) -&gt; Self:\n    from datetime import datetime, timedelta\n    import pandas as pd\n\n    # \u8f6c\u6362\u65e5\u671f\u5b57\u7b26\u4e32\u4e3adatetime\u5bf9\u8c61\n    start_dt = datetime.strptime(start_date, \"%Y-%m-%d\")\n    end_dt = datetime.strptime(end_date, \"%Y-%m-%d\")\n\n    # \u521d\u59cb\u5316\u65f6\u95f4\u6233\u5217\u8868\n    timestamps = []\n\n    # \u9ed8\u8ba4\u4f7f\u75281\u5206\u949f\u95f4\u9694\n    interval = \"1m\"\n\n    # \u5b9a\u4e49\u9884\u671f\u7684\u95f4\u9694\uff08\u5fae\u79d2\uff09\n    expected_interval_micros = 60 * 1000000  # 1\u5206\u949f = 60\u79d2 = 60,000,000\u5fae\u79d2\n\n    # \u8f6c\u6362\u65e5\u671f\u8303\u56f4\u4e3a\u65f6\u95f4\u6233\uff08\u5fae\u79d2\uff09\n    start_timestamp = int(start_dt.timestamp() * 1000000)\n    end_timestamp = int(end_dt.timestamp() * 1000000)\n\n    # \u4ece\u6240\u6709\u4ea4\u6613\u5bf9\u4e2d\u6536\u96c6\u65f6\u95f4\u6233\n    all_timestamps = set()\n\n    for symbol in symbols:\n        symbol_key = f\"{symbol}_klines_{interval}\"\n\n        if symbol_key in library.list_symbols():\n            try:\n                # \u8bfb\u53d6\u6570\u636e\n                result = library.read(symbol_key).data\n\n                df_pandas: pd.DataFrame = result \n\n                # \u68c0\u67e5\u6570\u636e\u662f\u5426\u4e3a\u7a7a\n                if not df_pandas.empty:\n                    # \u83b7\u53d6\u5217\u548c\u7d22\u5f15\u4fe1\u606f\n                    columns = df_pandas.columns.tolist()\n\n                    # \u60c5\u51b51: \"Close Time\" \u4f5c\u4e3a\u666e\u901a\u5217\n                    if \"Close Time\" in columns:\n                        all_timestamps.update(\n                            ts for ts in df_pandas[\"Close Time\"] \n                            if start_timestamp &lt;= ts &lt;= end_timestamp\n                        )\n                    # \u60c5\u51b52: \u7d22\u5f15\u53ef\u80fd\u662f\u65f6\u95f4\u6233\uff08\u68c0\u67e5\u7d22\u5f15\u540d\u79f0\u6216\u7c7b\u578b\uff09\n                    elif df_pandas.index.name == \"Close Time\" or isinstance(df_pandas.index, pd.DatetimeIndex):\n                        # \u5982\u679c\u7d22\u5f15\u662fDatetimeIndex\uff0c\u9700\u8981\u8f6c\u6362\u4e3a\u5fae\u79d2\u65f6\u95f4\u6233\n                        if isinstance(df_pandas.index, pd.DatetimeIndex):\n                            index_timestamps = (df_pandas.index.astype(int) // 1000).tolist()  # \u7eb3\u79d2\u8f6c\u5fae\u79d2\n                        else:\n                            index_timestamps = df_pandas.index.tolist()\n\n                        all_timestamps.update(\n                            ts for ts in index_timestamps\n                            if start_timestamp &lt;= ts &lt;= end_timestamp\n                        )\n                    else:\n                        print(f\"\u8b66\u544a: {symbol_key} \u4e2d\u6ca1\u6709\u627e\u5230 'Close Time' \u5217\u6216\u65f6\u95f4\u7d22\u5f15\")\n\n            except Exception as e:\n                print(f\"\u5904\u7406\u4ea4\u6613\u5bf9 {symbol} \u65f6\u51fa\u9519: {e}\")\n\n    # \u5c06\u96c6\u5408\u8f6c\u6362\u4e3a\u5217\u8868\u5e76\u6392\u5e8f\n    timestamps = sorted(all_timestamps)\n\n    # \u68c0\u67e5\u65f6\u95f4\u6233\u95f4\u9694\n    if len(timestamps) &gt; 1:\n        # \u8ba1\u7b97\u6240\u6709\u76f8\u90bb\u65f6\u95f4\u6233\u4e4b\u95f4\u7684\u95f4\u9694\n        intervals = [timestamps[i+1] - timestamps[i] for i in range(len(timestamps)-1)]\n\n        # \u7edf\u8ba1\u5206\u6790\n        min_interval = min(intervals)\n        max_interval = max(intervals)\n        avg_interval = sum(intervals) / len(intervals)\n\n        print(f\"\u65f6\u95f4\u6233\u95f4\u9694\u7edf\u8ba1:\")\n        print(f\"  \u6700\u5c0f\u95f4\u9694: {min_interval} \u5fae\u79d2 ({min_interval/1000000} \u79d2)\")\n        print(f\"  \u6700\u5927\u95f4\u9694: {max_interval} \u5fae\u79d2 ({max_interval/1000000} \u79d2)\")\n        print(f\"  \u5e73\u5747\u95f4\u9694: {avg_interval} \u5fae\u79d2 ({avg_interval/1000000} \u79d2)\")\n\n        # \u68c0\u67e5\u662f\u5426\u6240\u6709\u95f4\u9694\u90fd\u7b26\u5408\u9884\u671f\n        one_minute_micros = 60 * 1000000  # 1\u5206\u949f\u7684\u5fae\u79d2\u6570\n        tolerance = 0  # \u5141\u8bb80\u8bef\u5dee\n\n        all_one_minute = all(abs(interval - one_minute_micros) &lt;= tolerance for interval in intervals)\n\n        if all_one_minute:\n            print(f\"\u2713 \u6240\u6709\u65f6\u95f4\u6233\u95f4\u9694\u90fd\u5728\u9884\u671f\u76841\u5206\u949f\u8303\u56f4\u5185\uff08\u5141\u8bb80\u79d2\u8bef\u5dee\uff09\")\n        else:\n            # \u8ba1\u7b97\u4e0d\u7b26\u5408\u9884\u671f\u7684\u95f4\u9694\u6570\u91cf\n            non_compliant = sum(1 for interval in intervals if abs(interval - one_minute_micros) &gt; tolerance)\n            print(f\"\u26a0\ufe0f \u53d1\u73b0 {non_compliant}/{len(intervals)} \u4e2a\u65f6\u95f4\u6233\u95f4\u9694\u4e0d\u7b26\u5408\u9884\u671f\u76841\u5206\u949f\")\n\n            # \u5982\u679c\u4e0d\u7b26\u5408\u7684\u95f4\u9694\u592a\u591a\uff0c\u53ef\u4ee5\u9009\u62e9\u4fee\u590d\u6216\u7ed9\u51fa\u8b66\u544a\n            if non_compliant &gt; len(intervals) * 0.1:  # \u5982\u679c\u8d85\u8fc710%\u7684\u95f4\u9694\u4e0d\u7b26\u5408\u9884\u671f\n                print(\"\u26a0\ufe0f \u8b66\u544a: \u5927\u91cf\u65f6\u95f4\u6233\u95f4\u9694\u4e0d\u7b26\u5408\u9884\u671f\uff0c\u53ef\u80fd\u4f1a\u5f71\u54cd\u56de\u6d4b\u51c6\u786e\u6027\")\n\n    print(f\"\u521d\u59cb\u5316\u4e86 {len(timestamps)} \u4e2a\u65f6\u95f4\u6233\uff0c\u4ece {start_date} \u5230 {end_date}\")\n    if timestamps:\n        first_dt = datetime.fromtimestamp(timestamps[0]/1000000)\n        last_dt = datetime.fromtimestamp(timestamps[-1]/1000000)\n        print(f\"\u65f6\u95f4\u6233\u8303\u56f4: {first_dt.isoformat()} \u5230 {last_dt.isoformat()}\")\n\n    # \u521b\u5efa\u5b9e\u4f8b\u5e76\u8bbe\u7f6e\u65f6\u95f4\u6233\n    instance = cls(library=library)\n\n\n    instance.timestamps = timestamps\n    instance.now_index = timestamps[0]\n    instance.interval = expected_interval_micros\n    print(f\"\u8d77\u59cb\u65f6\u95f4\u6233: {instance.now_index} ({datetime.fromtimestamp(instance.now_index/1000000).isoformat()})\")   \n\n    # \u521d\u59cb\u5316\u6a21\u62df\u8d26\u6237\u6570\u636e\n    instance.monitor_account = {\n        \"makerCommission\": 15,\n        \"takerCommission\": 15,\n        \"buyerCommission\": 0,\n        \"sellerCommission\": 0,\n        \"commissionRates\": {\n            \"maker\": \"0.00150000\",\n            \"taker\": \"0.00150000\",\n            \"buyer\": \"0.00000000\",\n            \"seller\": \"0.00000000\"\n        },\n        \"canTrade\": True,\n        \"canWithdraw\": True,\n        \"canDeposit\": True,\n        \"brokered\": False,\n        \"requireSelfTradePrevention\": False,\n        \"preventSor\": False,\n        \"updateTime\": 0,\n        \"accountType\": \"SPOT\",\n        \"balances\": [],\n        \"permissions\": [\n            \"SPOT\"\n        ],\n        \"uid\": 123456789\n    }\n\n    # \u6dfb\u52a0 USDT \u4f59\u989d\n    instance.monitor_account[\"balances\"].append({\n        \"asset\": \"USDT\",\n        \"free\": \"10000.00000000\",\n        \"locked\": \"0.00000000\"\n    })\n\n    # \u6dfb\u52a0\u6240\u6709\u4ea4\u6613\u5bf9\u7684\u57fa\u7840\u8d27\u5e01\u4f59\u989d\n    for symbol in symbols:\n        base_asset = symbol.replace(\"USDT\", \"\")\n        instance.monitor_account[\"balances\"].append({\n            \"asset\": base_asset,\n            \"free\": \"0.00000000\",\n            \"locked\": \"0.00000000\"\n        })\n\n    return instance\n</code></pre>"},{"location":"reference/qoc/api/offline/#qoc.api.offline.ApiOffline.exchange_info","title":"exchange_info","text":"<pre><code>exchange_info(\n    symbol: str | None = None,\n    symbols: list[str] | None = None,\n    permissions: list[str] | None = None,\n) -&gt; None\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>def exchange_info(\n    self,\n    symbol: str | None = None,\n    symbols: list[str] | None = None,\n    permissions: list[str] | None = None,\n) -&gt; None:\n\n    # TODO(liblaf): Implement.\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/qoc/api/offline/#qoc.api.offline.ApiOffline.klines","title":"klines","text":"<pre><code>klines(\n    symbol: str,\n    interval: Interval,\n    *,\n    start_time: datetime | None = None,\n    **kwargs,\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>@override\ndef klines(\n    self,\n    symbol: str,\n    interval: Interval,\n    *,\n    start_time: datetime | None = None,\n    **kwargs,\n) -&gt; DataFrame:\n    import polars as pl\n\n    symbol_key = f\"{symbol}_klines_{interval}\"\n    if not self.library.has_symbol(symbol_key):\n        raise ValueError(f\"Symbol {symbol_key} not found in library\")\n\n    # \u8bfb\u53d6\u6570\u636e\n    df = self.library.read(symbol_key).data\n\n    # \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u6233\u7684\u6570\u636e\u884c\n    klines_now = df[df.index == self.now_index]\n\n    # \u68c0\u67e5\u6570\u636e\u662f\u5426\u5b58\u5728\n    if klines_now.empty:\n        print(f\"\u8b66\u544a: \u65f6\u95f4\u6233 {self.now_index} \u7684\u6570\u636e\u4e0d\u5b58\u5728\")\n        return pl.DataFrame()\n\n    # \u5217\u540d\u6620\u5c04 - \u4ece ArcticDB \u683c\u5f0f\u8f6c\u6362\u4e3a Polars \u683c\u5f0f\n    column_mapping = {\n        'Open Time': 'open_time',\n        'Open': 'open',\n        'High': 'high',\n        'Low': 'low',\n        'Close': 'close',\n        'Volume': 'volume',\n        'Close Time': 'close_time',  # \u7d22\u5f15\u5217\u4e5f\u9700\u8981\u6620\u5c04\n        'Quote Asset Volume': 'quote_volume',\n        'Number of Trades': 'count',\n        'Taker Buy Base Volume': 'taker_buy_volume',\n        'Taker Buy Quote Volume': 'taker_buy_quote_volume',\n        'Ignore': 'ignore'\n    }\n\n    # \u91cd\u7f6e\u7d22\u5f15\uff0c\u4f7f Close Time \u6210\u4e3a\u666e\u901a\u5217\n    klines_now = klines_now.reset_index()\n\n    # \u91cd\u547d\u540d\u5217\n    renamed_cols = {}\n    for old_col, new_col in column_mapping.items():\n        if old_col in klines_now.columns:\n            renamed_cols[old_col] = new_col\n\n    klines_now = klines_now.rename(columns=renamed_cols)\n\n    # \u8f6c\u6362\u4e3a Polars DataFrame\n    pl_data = pl.from_pandas(klines_now)\n\n    # \u786e\u4fdd\u8fd4\u56de\u7684 DataFrame \u6709\u6b63\u786e\u7684\u5217\u7c7b\u578b\n    schema = {\n        'open_time': int,\n        'open': pl.Float64,\n        'high': pl.Float64,\n        'low': pl.Float64,\n        'close': pl.Float64,\n        'volume': pl.Float64,\n        'close_time': int,\n        'quote_volume': pl.Float64,\n        'count': pl.Int64,\n        'taker_buy_volume': pl.Float64,\n        'taker_buy_quote_volume': pl.Float64,\n        'ignore': pl.Int64\n    }\n\n    # \u5e94\u7528\u7c7b\u578b\u8f6c\u6362\n    for col, dtype in schema.items():\n        if col in pl_data.columns:\n            if dtype == pl.Datetime and pl_data[col].dtype != pl.Datetime:\n                # \u5982\u679c\u662f\u65e5\u671f\u5217\u4e14\u9700\u8981\u8f6c\u6362\n                if pl_data[col].dtype in (pl.Int64, pl.Float64):\n                    # \u5047\u8bbe\u65f6\u95f4\u6233\u662f\u5fae\u79d2\u7ea7\u7684\n                    pl_data = pl_data.with_columns(\n                        pl.col(col).cast(pl.Int64).cast(pl.Datetime(time_unit=\"us\"))\n                    )\n            else:\n                # \u5176\u4ed6\u5217\u7c7b\u578b\u8f6c\u6362\n                pl_data = pl_data.with_columns(\n                    pl.col(col).cast(dtype)\n                )\n\n\n    return pl_data\n</code></pre>"},{"location":"reference/qoc/api/offline/#qoc.api.offline.ApiOffline.order_market","title":"order_market","text":"<pre><code>order_market(\n    symbol: str,\n    side: OrderSideLike,\n    *,\n    quantity: float | None = None,\n    quoteOrderQty: float | None = None,\n    timestamp: datetime | None = None,\n    lock_rate: float = 1.0,\n    **kwargs,\n) -&gt; OrderResponseFull\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>@override\ndef order_market(\n    self,\n    symbol: str,\n    side: OrderSideLike,\n    *,\n    quantity: float | None = None,\n    quoteOrderQty: float | None = None,\n    timestamp: datetime | None = None,\n    lock_rate: float = 1.0,  # \u4fdd\u8bc1\u91d1\u500d\u6570\u53c2\u6570\uff0c\u9ed8\u8ba4\u4e3a1\u500d\n    **kwargs,\n) -&gt; OrderResponseFull:\n    now = self.now_index\n    transaction_fee = 0.001  # \u4ea4\u6613\u8d39\u7528\u4e3a0.1%\n\n    try:\n        # \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u70b9\u7684\u4ef7\u683c\u6570\u636e\n        symbol_key = f\"{symbol}_klines_1m\"\n\n        if not self.library.has_symbol(symbol_key):\n            raise ValueError(f\"Symbol {symbol_key} not found in library\")\n\n        # \u8bfb\u53d6\u6570\u636e\n        df = self.library.read(symbol_key).data\n\n        # \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u6233\u5bf9\u5e94\u7684\u884c\n        price_row = df[df.index == now]\n\n        if price_row.empty:\n            raise ValueError(f\"No price data found for timestamp {now}\")\n\n        # \u83b7\u53d6\u6536\u76d8\u4ef7\u5e76\u786e\u4fdd\u662ffloat\u7c7b\u578b\n        try:\n            price = float(price_row['Close'].iloc[0])\n        except (ValueError, TypeError):\n            # \u5982\u679c\u8f6c\u6362\u5931\u8d25\uff0c\u5c1d\u8bd5\u5176\u4ed6\u5217\u540d\uff08\u5927\u5c0f\u5199\u4e0d\u540c\uff09\n            try:\n                price = float(price_row['close'].iloc[0])\n            except (ValueError, TypeError, KeyError):\n                raise ValueError(f\"\u65e0\u6cd5\u83b7\u53d6\u6709\u6548\u7684\u6536\u76d8\u4ef7\u683c\u6570\u636e (\u65f6\u95f4\u6233: {now})\")\n\n        print(f\"\u6267\u884c\u5e02\u4ef7\u5355: {symbol}, \u65b9\u5411: {side}, \u4ef7\u683c: {price}, \u6570\u91cf: {quantity}\")\n\n        # \u4ea4\u6613\u7684\u57fa\u7840\u8d44\u4ea7\u548c\u62a5\u4ef7\u8d44\u4ea7\n        base_asset = symbol.replace(\"USDT\", \"\")\n        quote_asset = \"USDT\"\n\n        # \u8f85\u52a9\u51fd\u6570\uff1a\u83b7\u53d6\u8d44\u4ea7\u4f59\u989d\n        def get_asset_balance(asset, balance_type=\"free\"):\n            for balance in self.monitor_account[\"balances\"]:\n                if balance[\"asset\"] == asset:\n                    return float(balance[balance_type])\n            return 0.0\n\n        # \u8f85\u52a9\u51fd\u6570\uff1a\u66f4\u65b0\u8d44\u4ea7\u4f59\u989d\n        def update_asset_balance(asset, amount, balance_type=\"free\"):\n            for balance in self.monitor_account[\"balances\"]:\n                if balance[\"asset\"] == asset:\n                    current_amount = float(balance[balance_type])\n                    balance[balance_type] = str(current_amount + amount)\n                    return\n\n            # \u5982\u679c\u8d44\u4ea7\u4e0d\u5b58\u5728\uff0c\u6dfb\u52a0\u65b0\u8d44\u4ea7\n            new_balance = {\n                \"asset\": asset,\n                \"free\": \"0.00000000\",\n                \"locked\": \"0.00000000\"\n            }\n            new_balance[balance_type] = str(amount)\n            self.monitor_account[\"balances\"].append(new_balance)\n\n        # \u4e70\u5165\u903b\u8f91\n        if side == \"BUY\":\n            if quantity is None:\n                raise ValueError(\"Must provide quantity for BUY order\")\n\n            # \u8ba1\u7b97\u6240\u9700\u7684USDT\u91d1\u989d\uff08\u5305\u542b\u624b\u7eed\u8d39\uff09\n            quote_amount = quantity * price\n            fee_amount = quote_amount * transaction_fee\n            total_cost = quote_amount + fee_amount\n\n            # \u68c0\u67e5\u4f59\u989d\u662f\u5426\u8db3\u591f\n            usdt_free = get_asset_balance(quote_asset)\n            if usdt_free &lt; total_cost:\n                raise ValueError(f\"Insufficient {quote_asset} balance: {usdt_free} &lt; {total_cost}\")\n\n            # \u76f4\u63a5\u6263\u9664USDT\u4f59\u989d\n            update_asset_balance(quote_asset, -total_cost)\n            # \u589e\u52a0\u57fa\u7840\u8d44\u4ea7\n            update_asset_balance(base_asset, quantity)\n\n            print(f\"\u4e70\u5165 {quantity} {base_asset} \u82b1\u8d39 {total_cost} {quote_asset} (\u542b\u624b\u7eed\u8d39 {fee_amount})\")\n\n        # \u5356\u51fa\u903b\u8f91\n        elif side == \"SELL\":\n            if quantity is None:\n                raise ValueError(\"Must provide quantity for SELL order\")\n\n            # \u68c0\u67e5\u57fa\u7840\u8d44\u4ea7\u4f59\u989d\n            base_free = get_asset_balance(base_asset)\n\n            # \u8ba1\u7b97\u5356\u51fa\u7684USDT\u91d1\u989d\n            quote_amount = quantity * price\n            fee_amount = quote_amount * transaction_fee\n            net_received = quote_amount - fee_amount\n\n            # \u60c5\u51b51: \u6709\u8db3\u591f\u4f59\u989d\u76f4\u63a5\u5356\u51fa\n            if base_free &gt;= quantity:\n                update_asset_balance(base_asset, -quantity)\n                update_asset_balance(quote_asset, net_received)\n                print(f\"\u5356\u51fa {quantity} {base_asset} \u83b7\u5f97 {net_received} {quote_asset} (\u6263\u9664\u624b\u7eed\u8d39 {fee_amount})\")\n\n            # \u60c5\u51b52: \u4f59\u989d\u4e0d\u8db3\uff0c\u5148\u5356\u51fa\u5df2\u6709\u4f59\u989d\uff0c\u518d\u505a\u7a7a\u5269\u4f59\u90e8\u5206\n            else:\n                # \u5206\u4e24\u90e8\u5206\u5904\u7406\n                # 1. \u5148\u5356\u51fa\u5df2\u6709\u7684\u4f59\u989d\n                if base_free &gt; 0:\n                    partial_quote_amount = base_free * price\n                    partial_fee = partial_quote_amount * transaction_fee\n                    partial_net = partial_quote_amount - partial_fee\n\n                    update_asset_balance(base_asset, -base_free)\n                    update_asset_balance(quote_asset, partial_net)\n                    print(f\"\u5356\u51fa\u53ef\u7528\u4f59\u989d {base_free} {base_asset} \u83b7\u5f97 {partial_net} {quote_asset}\")\n\n                # 2. \u5269\u4f59\u90e8\u5206\u4f7f\u7528\u4fdd\u8bc1\u91d1\u505a\u7a7a\n                remaining_quantity = quantity - base_free\n                short_quote_amount = remaining_quantity * price\n                short_fee = short_quote_amount * transaction_fee\n\n                # \u8ba1\u7b97\u9700\u8981\u9501\u5b9a\u7684\u4fdd\u8bc1\u91d1 (\u4f7f\u7528lock_rate\u500d\u4fdd\u8bc1\u91d1)\n                required_margin = short_quote_amount / lock_rate\n\n                # \u68c0\u67e5USDT\u4f59\u989d\u662f\u5426\u8db3\u591f\u4f5c\u4e3a\u4fdd\u8bc1\u91d1\n                if get_asset_balance(quote_asset) &lt; required_margin:\n                    raise ValueError(f\"Insufficient {quote_asset} for margin: {get_asset_balance(quote_asset)} &lt; {required_margin}\")\n\n                # \u9501\u5b9a\u4fdd\u8bc1\u91d1 (\u4ecefree\u79fb\u5230locked)\n                update_asset_balance(quote_asset, -required_margin)\n                update_asset_balance(quote_asset, required_margin, \"locked\")\n\n                # \u521b\u5efa\u505a\u7a7a\u5934\u5bf8\u8bb0\u5f55 (\u53ef\u4ee5\u6dfb\u52a0\u5230\u76d1\u63a7\u8d26\u6237\u7684\u989d\u5916\u5b57\u6bb5\u4e2d)\n                # \u8fd9\u91cc\u7b80\u5316\u5904\u7406\uff0c\u53ea\u5728base_asset\u4e2d\u8bb0\u5f55\u8d1f\u6570\u4f59\u989d\n                update_asset_balance(base_asset, -remaining_quantity)\n                update_asset_balance(quote_asset, short_quote_amount - short_fee)\n\n                print(f\"\u505a\u7a7a {remaining_quantity} {base_asset} \u4f7f\u7528\u4fdd\u8bc1\u91d1 {required_margin} {quote_asset} (\u6760\u6746\u7387: {lock_rate})\")\n                print(f\"\u505a\u7a7a\u83b7\u5f97 {short_quote_amount - short_fee} {quote_asset} (\u6263\u9664\u624b\u7eed\u8d39 {short_fee})\")\n\n        # \u521b\u5efa\u8ba2\u5355\u54cd\u5e94\u5bf9\u8c61\n        from qoc.api.typing import OrderResponseFull, OrderResponseFill, OrderType, OrderSide\n        import datetime\n        import uuid\n\n        # \u521b\u5efa\u4e00\u4e2a\u552f\u4e00\u7684\u5ba2\u6237\u7aef\u8ba2\u5355ID\n        client_order_id = f\"offline_{uuid.uuid4().hex[:16]}\"\n\n        # \u521b\u5efafills\u5217\u8868 (\u6210\u4ea4\u660e\u7ec6)\n        fills = [\n            OrderResponseFill(\n                price=price,\n                qty=quantity,\n                commission=fee_amount,  # \u624b\u7eed\u8d39\n                commissionasset=quote_asset,  # \u624b\u7eed\u8d39\u8d44\u4ea7\n                tradeid=int(now % 1000000)  # \u4f7f\u7528\u65f6\u95f4\u6233\u90e8\u5206\u4f5c\u4e3a\u4ea4\u6613ID\n            )\n        ]\n\n        # \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u4f5c\u4e3a\u4ea4\u6613\u65f6\u95f4\n        current_time = datetime.datetime.fromtimestamp(now / 1000000)\n\n        # \u8f6c\u6362side\u5b57\u7b26\u4e32\u4e3aOrderSide\u679a\u4e3e\n        order_side = OrderSide(side)\n\n        # \u6784\u5efa\u5e76\u8fd4\u56deOrderResponseFull\u5bf9\u8c61\n        return OrderResponseFull(\n            symbol=symbol,\n            clientorderid=client_order_id,\n            transacttime=current_time,\n            price=price,\n            origqty=quantity if quantity is not None else 0.0,\n            executedqty=quantity if quantity is not None else 0.0,\n            origquoteorderqty=quoteOrderQty if quoteOrderQty is not None else 0.0,\n            cummulativequoteqty=quote_amount if 'quote_amount' in locals() else 0.0,  # \u603b\u4ef7\u503c\n            type=OrderType.MARKET,  # \u5e02\u4ef7\u5355\n            side=order_side,\n            workingtime=current_time,\n            fills=fills,\n            # \u6dfb\u52a0\u6269\u5c55\u5c5e\u6027 (\u5982\u679c\u652f\u6301\u7684\u8bdd)\n            # lockRate is not a valid parameter, removing it\n            # isShort is not a valid parameter, removing it\n        )\n\n    except Exception as e:\n        print(f\"\u6267\u884c\u5e02\u4ef7\u5355\u51fa\u9519: {e}\")\n        raise\n</code></pre>"},{"location":"reference/qoc/api/offline/#qoc.api.offline.ApiOffline.step","title":"step","text":"<pre><code>step() -&gt; bool\n</code></pre> Source code in <code>src/qoc/api/offline/_offline.py</code> <pre><code>def step(self) -&gt; bool:\n    if self.now_index + self.interval &lt;= self.timestamps[-1]:\n        self.now_index += self.interval\n        print(f\"\u65f6\u95f4\u63a8\u8fdb\u5230: {self.now_index} \")\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/qoc/api/typing/","title":"qoc.api.typing","text":""},{"location":"reference/qoc/api/typing/#qoc.api.typing","title":"qoc.api.typing","text":"<p>Type Aliases:</p> <ul> <li> <code>Interval</code>           \u2013            </li> <li> <code>OrderSideLike</code>           \u2013            </li> <li> <code>OrderTypeLike</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Account</code>           \u2013            <p>.</p> </li> <li> <code>BaseModel</code>           \u2013            </li> <li> <code>OrderResponseFill</code>           \u2013            </li> <li> <code>OrderResponseFull</code>           \u2013            </li> <li> <code>OrderSide</code>           \u2013            </li> <li> <code>OrderType</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.Interval","title":"Interval","text":"<pre><code>Interval = Literal[\n    \"1s\",\n    \"1m\",\n    \"3m\",\n    \"5m\",\n    \"15m\",\n    \"30m\",\n    \"1h\",\n    \"2h\",\n    \"4h\",\n    \"6h\",\n    \"8h\",\n    \"12h\",\n    \"1d\",\n    \"3d\",\n    \"1w\",\n    \"1M\",\n]\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderSideLike","title":"OrderSideLike","text":"<pre><code>OrderSideLike = OrderSide | Literal['BUY', 'SELL']\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderTypeLike","title":"OrderTypeLike","text":"<pre><code>OrderTypeLike = (\n    OrderType\n    | Literal[\n        \"LIMIT\",\n        \"MARKET\",\n        \"STOP_LOSS\",\n        \"STOP_LOSS_LIMIT\",\n        \"TAKE_PROFIT\",\n        \"TAKE_PROFIT_LIMIT\",\n        \"LIMIT_MAKER\",\n    ]\n)\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.Account","title":"Account","text":"<p>               Bases: <code>BaseModel</code></p> <p>.</p> Example <pre><code>{\n    \"makerCommission\": 15,\n    \"takerCommission\": 15,\n    \"buyerCommission\": 0,\n    \"sellerCommission\": 0,\n    \"commissionRates\": {\n        \"maker\": \"0.00150000\",\n        \"taker\": \"0.00150000\",\n        \"buyer\": \"0.00000000\",\n        \"seller\": \"0.00000000\"\n    },\n    \"canTrade\": true,\n    \"canWithdraw\": true,\n    \"canDeposit\": true,\n    \"brokered\": false,\n    \"requireSelfTradePrevention\": false,\n    \"preventSor\": false,\n    \"updateTime\": 123456789,\n    \"accountType\": \"SPOT\",\n    \"balances\": [\n        {\n            \"asset\": \"BTC\",\n            \"free\": \"4723846.89208129\",\n            \"locked\": \"0.00000000\"\n        },\n        {\n            \"asset\": \"LTC\",\n            \"free\": \"4763368.68006011\",\n            \"locked\": \"0.00000000\"\n        }\n    ],\n    \"permissions\": [\n        \"SPOT\"\n    ],\n    \"uid\": 354937868\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>commission_rates</code>               (<code>CommissionRates</code>)           \u2013            </li> <li> <code>balances</code>               (<code>list[Balance]</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>balances</code>               (<code>list[Balance]</code>)           \u2013            </li> <li> <code>commission_rates</code>               (<code>CommissionRates</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.Account.balances","title":"balances  <code>instance-attribute</code>","text":"<pre><code>balances: list[Balance]\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.Account.commission_rates","title":"commission_rates  <code>instance-attribute</code>","text":"<pre><code>commission_rates: CommissionRates\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.Account.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"allow\", alias_generator=to_camel\n)\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.BaseModel","title":"BaseModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> <ul> <li> <code>model_config</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.BaseModel.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"allow\", alias_generator=to_camel\n)\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFill","title":"OrderResponseFill","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> <ul> <li> <code>price</code>               (<code>float</code>)           \u2013            </li> <li> <code>qty</code>               (<code>float</code>)           \u2013            </li> <li> <code>commission</code>               (<code>float</code>)           \u2013            </li> <li> <code>commissionasset</code>               (<code>str</code>)           \u2013            </li> <li> <code>tradeid</code>               (<code>int</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>commission</code>               (<code>float</code>)           \u2013            </li> <li> <code>commissionasset</code>               (<code>str</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> <li> <code>price</code>               (<code>float</code>)           \u2013            </li> <li> <code>qty</code>               (<code>float</code>)           \u2013            </li> <li> <code>tradeid</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFill.commission","title":"commission  <code>instance-attribute</code>","text":"<pre><code>commission: float\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFill.commissionasset","title":"commissionasset  <code>instance-attribute</code>","text":"<pre><code>commissionasset: str\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFill.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"allow\", alias_generator=to_camel\n)\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFill.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: float\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFill.qty","title":"qty  <code>instance-attribute</code>","text":"<pre><code>qty: float\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFill.tradeid","title":"tradeid  <code>instance-attribute</code>","text":"<pre><code>tradeid: int\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull","title":"OrderResponseFull","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> <ul> <li> <code>symbol</code>               (<code>str</code>)           \u2013            </li> <li> <code>clientorderid</code>               (<code>str</code>)           \u2013            </li> <li> <code>transacttime</code>               (<code>datetime</code>)           \u2013            </li> <li> <code>price</code>               (<code>float</code>)           \u2013            </li> <li> <code>origqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>executedqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>origquoteorderqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>cummulativequoteqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>type</code>               (<code>OrderType</code>)           \u2013            </li> <li> <code>side</code>               (<code>OrderSide</code>)           \u2013            </li> <li> <code>workingtime</code>               (<code>datetime</code>)           \u2013            </li> <li> <code>fills</code>               (<code>list[OrderResponseFill]</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>clientorderid</code>               (<code>str</code>)           \u2013            </li> <li> <code>cummulativequoteqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>executedqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>fills</code>               (<code>list[OrderResponseFill]</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> <li> <code>origqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>origquoteorderqty</code>               (<code>float</code>)           \u2013            </li> <li> <code>price</code>               (<code>float</code>)           \u2013            </li> <li> <code>side</code>               (<code>OrderSide</code>)           \u2013            </li> <li> <code>symbol</code>               (<code>str</code>)           \u2013            </li> <li> <code>transacttime</code>               (<code>datetime</code>)           \u2013            </li> <li> <code>type</code>               (<code>OrderType</code>)           \u2013            </li> <li> <code>workingtime</code>               (<code>datetime</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull.clientorderid","title":"clientorderid  <code>instance-attribute</code>","text":"<pre><code>clientorderid: str\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull.cummulativequoteqty","title":"cummulativequoteqty  <code>instance-attribute</code>","text":"<pre><code>cummulativequoteqty: float\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull.executedqty","title":"executedqty  <code>instance-attribute</code>","text":"<pre><code>executedqty: float\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull.fills","title":"fills  <code>instance-attribute</code>","text":"<pre><code>fills: list[OrderResponseFill]\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"allow\", alias_generator=to_camel\n)\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull.origqty","title":"origqty  <code>instance-attribute</code>","text":"<pre><code>origqty: float\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull.origquoteorderqty","title":"origquoteorderqty  <code>instance-attribute</code>","text":"<pre><code>origquoteorderqty: float\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: float\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull.side","title":"side  <code>instance-attribute</code>","text":"<pre><code>side: OrderSide\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull.symbol","title":"symbol  <code>instance-attribute</code>","text":"<pre><code>symbol: str\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull.transacttime","title":"transacttime  <code>instance-attribute</code>","text":"<pre><code>transacttime: datetime\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: OrderType = Field(alias='type')\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderResponseFull.workingtime","title":"workingtime  <code>instance-attribute</code>","text":"<pre><code>workingtime: datetime\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderSide","title":"OrderSide","text":"<p>               Bases: <code>CaseInsensitiveEnum</code></p> <p>Attributes:</p> <ul> <li> <code>BUY</code>           \u2013            </li> <li> <code>SELL</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderSide.BUY","title":"BUY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUY = auto()\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderSide.SELL","title":"SELL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SELL = auto()\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderType","title":"OrderType","text":"<p>               Bases: <code>CaseInsensitiveEnum</code></p> <p>Attributes:</p> <ul> <li> <code>LIMIT</code>           \u2013            </li> <li> <code>LIMIT_MAKER</code>           \u2013            </li> <li> <code>MARKET</code>           \u2013            </li> <li> <code>STOP_LOSS</code>           \u2013            </li> <li> <code>STOP_LOSS_LIMIT</code>           \u2013            </li> <li> <code>TAKE_PROFIT</code>           \u2013            </li> <li> <code>TAKE_PROFIT_LIMIT</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderType.LIMIT","title":"LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIMIT = auto()\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderType.LIMIT_MAKER","title":"LIMIT_MAKER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIMIT_MAKER = auto()\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderType.MARKET","title":"MARKET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MARKET = auto()\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderType.STOP_LOSS","title":"STOP_LOSS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOP_LOSS = auto()\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderType.STOP_LOSS_LIMIT","title":"STOP_LOSS_LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOP_LOSS_LIMIT = auto()\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderType.TAKE_PROFIT","title":"TAKE_PROFIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAKE_PROFIT = auto()\n</code></pre>"},{"location":"reference/qoc/api/typing/#qoc.api.typing.OrderType.TAKE_PROFIT_LIMIT","title":"TAKE_PROFIT_LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAKE_PROFIT_LIMIT = auto()\n</code></pre>"},{"location":"reference/qoc/balance/","title":"qoc.balance","text":""},{"location":"reference/qoc/balance/#qoc.balance","title":"qoc.balance","text":"<p>Classes:</p> <ul> <li> <code>Balance</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/balance/#qoc.balance.Balance","title":"Balance","text":"<p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>symbols</code>               (<code>list[str]</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>step</code>             \u2013              </li> <li> <code>step_offline</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>symbols</code>               (<code>list[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/balance/#qoc.balance.Balance.library","title":"library  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library: Library = field()\n</code></pre>"},{"location":"reference/qoc/balance/#qoc.balance.Balance.symbols","title":"symbols  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbols: list[str] = field(factory=list)\n</code></pre>"},{"location":"reference/qoc/balance/#qoc.balance.Balance.step","title":"step","text":"<pre><code>step(\n    api: ApiBinance | ApiOffline,\n    market: Market,\n    now: datetime,\n) -&gt; None\n</code></pre> Source code in <code>src/qoc/balance/_balance.py</code> <pre><code>def step(self, api: _api.ApiBinance|_api.ApiOffline, market: market.Market, now: datetime) -&gt; None:\n    account: _api.Account = api.account()\n    balances_dict: dict[str, float] = {\n        b.asset: b.free + b.locked for b in account.balances\n    }\n    balances_df: pl.DataFrame = pl.from_dicts([balances_dict])\n    balances_df = utils.insert_time(balances_df, now)\n    self.library.append(\"balance\", balances_df)\n</code></pre>"},{"location":"reference/qoc/balance/#qoc.balance.Balance.step_offline","title":"step_offline","text":"<pre><code>step_offline(market, library, coins, interval, now) -&gt; None\n</code></pre> Source code in <code>src/qoc/balance/_balance.py</code> <pre><code>def step_offline(self, market, library, coins, interval, now) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/qoc/database/","title":"qoc.database","text":""},{"location":"reference/qoc/database/#qoc.database","title":"qoc.database","text":"<p>Classes:</p> <ul> <li> <code>Database</code>           \u2013            </li> <li> <code>Library</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/database/#qoc.database.Database","title":"Database","text":"<pre><code>Database(uri: str = 'mem://')\n</code></pre> <p>Methods:</p> <ul> <li> <code>get_library</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>db</code>               (<code>Arctic</code>)           \u2013            </li> </ul> Source code in <code>src/qoc/database/_database.py</code> <pre><code>def __init__(self, uri: str = \"mem://\") -&gt; None:\n    self.db = adb.Arctic(uri=uri)\n</code></pre>"},{"location":"reference/qoc/database/#qoc.database.Database.db","title":"db  <code>instance-attribute</code>","text":"<pre><code>db: Arctic = Arctic(uri=uri)\n</code></pre>"},{"location":"reference/qoc/database/#qoc.database.Database.get_library","title":"get_library","text":"<pre><code>get_library(\n    name: str, *, create_if_missing: bool = True, **kwargs\n) -&gt; Library\n</code></pre> Source code in <code>src/qoc/database/_database.py</code> <pre><code>def get_library(\n    self, name: str, *, create_if_missing: bool = True, **kwargs\n) -&gt; Library:\n    return Library(\n        self.db.get_library(name, create_if_missing=create_if_missing, **kwargs)\n    )\n</code></pre>"},{"location":"reference/qoc/database/#qoc.database.Library","title":"Library","text":"<p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>append</code>             \u2013              </li> <li> <code>append_batch</code>             \u2013              </li> <li> <code>get_latest_time</code>             \u2013              </li> <li> <code>has_symbol</code>             \u2013              </li> <li> <code>read</code>             \u2013              </li> <li> <code>tail</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/database/#qoc.database.Library.library","title":"library  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library: Library = field()\n</code></pre>"},{"location":"reference/qoc/database/#qoc.database.Library.append","title":"append","text":"<pre><code>append(\n    symbol: str, data: NormalizableType, /, **kwargs\n) -&gt; None\n</code></pre> Source code in <code>src/qoc/database/_library.py</code> <pre><code>@grapes.timer(\n    cb_stop=grapes.timing.callback.log_record(level=\"WARNING\", threshold_sec=0.0)\n)\ndef append(self, symbol: str, data: NormalizableType, /, **kwargs) -&gt; None:\n    data = self._normalize_data(data)\n    if self.has_symbol(symbol):\n        data = data[data.index &gt; self.get_latest_time(symbol)]\n    if data.empty:\n        return\n    self.library.append(symbol, data, **kwargs)\n</code></pre>"},{"location":"reference/qoc/database/#qoc.database.Library.append_batch","title":"append_batch","text":"<pre><code>append_batch(\n    data: Iterable[tuple[str, NormalizableType]],\n    /,\n    **kwargs,\n) -&gt; None\n</code></pre> Source code in <code>src/qoc/database/_library.py</code> <pre><code>@grapes.timer(\n    cb_stop=grapes.timing.callback.log_record(level=\"WARNING\", threshold_sec=0.0)\n)\ndef append_batch(\n    self, data: Iterable[tuple[str, NormalizableType]], /, **kwargs\n) -&gt; None:\n    payloads: list[adb.WritePayload] = []\n    for symbol, df in data:\n        df_normalized: pd.DataFrame = self._normalize_data(df)\n        if not df_normalized.empty:\n            payloads.append(adb.WritePayload(symbol, df_normalized))\n    self.library.append_batch(payloads, **kwargs)\n</code></pre>"},{"location":"reference/qoc/database/#qoc.database.Library.get_latest_time","title":"get_latest_time","text":"<pre><code>get_latest_time(symbol: str) -&gt; int\n</code></pre> Source code in <code>src/qoc/database/_library.py</code> <pre><code>def get_latest_time(self, symbol: str, /) -&gt; int:\n    data: pd.DataFrame = cast(\n        \"pd.DataFrame\", self.library.tail(symbol=symbol, n=1).data\n    )\n\n    latest_index = data.index[-1] \n\n    return latest_index\n</code></pre>"},{"location":"reference/qoc/database/#qoc.database.Library.has_symbol","title":"has_symbol","text":"<pre><code>has_symbol(symbol: str) -&gt; bool\n</code></pre> Source code in <code>src/qoc/database/_library.py</code> <pre><code>def has_symbol(self, symbol: str, /) -&gt; bool:\n    return self.library.has_symbol(symbol)\n</code></pre>"},{"location":"reference/qoc/database/#qoc.database.Library.read","title":"read","text":"<pre><code>read(\n    symbol: str,\n    date_range: tuple[TimeTypes | None, TimeTypes | None]\n    | None = None,\n    row_range: tuple[int, int] | None = None,\n    columns: Sequence[str] | None = None,\n    **kwargs,\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/database/_library.py</code> <pre><code>def read(\n    self,\n    symbol: str,\n    date_range: tuple[TimeTypes | None, TimeTypes | None] | None = None,\n    row_range: tuple[int, int] | None = None,\n    columns: Sequence[str] | None = None,\n    **kwargs,\n) -&gt; pd.DataFrame:\n    return cast(\n        \"pd.DataFrame\",\n        self.library.read(\n            symbol=symbol,\n            date_range=date_range,\n            row_range=row_range,\n            columns=columns,  # pyright: ignore[reportArgumentType]\n            **kwargs,\n        ).data,\n    )\n</code></pre>"},{"location":"reference/qoc/database/#qoc.database.Library.tail","title":"tail","text":"<pre><code>tail(\n    symbol: str,\n    n: int = 5,\n    columns: Sequence[str] | None = None,\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/database/_library.py</code> <pre><code>def tail(\n    self, symbol: str, n: int = 5, columns: Sequence[str] | None = None\n) -&gt; pd.DataFrame:\n    return cast(\n        \"pd.DataFrame\",\n        self.library.tail(symbol=symbol, n=n, columns=columns).data,  \n    )\n</code></pre>"},{"location":"reference/qoc/feature/","title":"qoc.feature","text":""},{"location":"reference/qoc/feature/#qoc.feature","title":"qoc.feature","text":"<p>Classes:</p> <ul> <li> <code>Feature</code>           \u2013            </li> <li> <code>FeaturePrice</code>           \u2013            <p>\u8ba1\u7b97\u4ef7\u683c\u7279\u5f81.</p> </li> </ul>"},{"location":"reference/qoc/feature/#qoc.feature.Feature","title":"Feature","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>compute</code>             \u2013              </li> </ul>"},{"location":"reference/qoc/feature/#qoc.feature.Feature.compute","title":"compute  <code>abstractmethod</code>","text":"<pre><code>compute(timestamp: Timestamp, state: State) -&gt; State\n</code></pre> Source code in <code>src/qoc/feature/_abc.py</code> <pre><code>@abc.abstractmethod\ndef compute(self, timestamp: struct.Timestamp, state: struct.State) -&gt; struct.State:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/qoc/feature/#qoc.feature.FeaturePrice","title":"FeaturePrice","text":"<p>               Bases: <code>PerCoinFeature</code></p> <p>\u8ba1\u7b97\u4ef7\u683c\u7279\u5f81.</p> <p>Methods:</p> <ul> <li> <code>compute</code>             \u2013              </li> <li> <code>compute_per_coin</code>             \u2013              </li> </ul>"},{"location":"reference/qoc/feature/#qoc.feature.FeaturePrice.compute","title":"compute","text":"<pre><code>compute(timestamp: Timestamp, state: State) -&gt; State\n</code></pre> Source code in <code>src/qoc/feature/_abc.py</code> <pre><code>@override\ndef compute(self, timestamp: struct.Timestamp, state: struct.State) -&gt; struct.State:\n    for coin in state.coins:\n        state = self.compute_per_coin(timestamp, state, coin)\n    return state\n</code></pre>"},{"location":"reference/qoc/feature/#qoc.feature.FeaturePrice.compute_per_coin","title":"compute_per_coin","text":"<pre><code>compute_per_coin(\n    timestamp: Timestamp, state: State, coin: CoinName\n) -&gt; State\n</code></pre> Source code in <code>src/qoc/feature/_price.py</code> <pre><code>@override\ndef compute_per_coin(\n    self, timestamp: struct.Timestamp, state: struct.State, coin: struct.CoinName\n) -&gt; struct.State:\n    current_price: float = state.raw[coin, \"low\"].latest\n    state.strategy.append({(coin, \"price\"): current_price}, timestamp)\n    return state\n</code></pre>"},{"location":"reference/qoc/market/","title":"qoc.market","text":""},{"location":"reference/qoc/market/#qoc.market","title":"qoc.market","text":"<p>Classes:</p> <ul> <li> <code>Market</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/market/#qoc.market.Market","title":"Market","text":"<p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>symbols</code>               (<code>list[str]</code>, default:                   <code>['BTCUSDT']</code> )           \u2013            </li> <li> <code>interval</code>               (<code>TypeAliasType</code>, default:                   <code>'1s'</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>convert</code>             \u2013              </li> <li> <code>step</code>             \u2013              </li> <li> <code>tail</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>interval</code>               (<code>Interval</code>)           \u2013            </li> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>symbols</code>               (<code>list[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/market/#qoc.market.Market.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interval: Interval = field(default='1s')\n</code></pre>"},{"location":"reference/qoc/market/#qoc.market.Market.library","title":"library  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library: Library = field()\n</code></pre>"},{"location":"reference/qoc/market/#qoc.market.Market.symbols","title":"symbols  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbols: list[str] = field(factory=lambda: ['BTCUSDT'])\n</code></pre>"},{"location":"reference/qoc/market/#qoc.market.Market.convert","title":"convert","text":"<pre><code>convert(qty: float, base: str, quote: str) -&gt; float\n</code></pre> Source code in <code>src/qoc/market/_market.py</code> <pre><code>def convert(self, qty: float, base: str, quote: str) -&gt; float:\n    if base == quote:\n        return qty\n    df: pd.DataFrame = self.library.tail(f\"{base}{quote}\", n=1, columns=[\"close\"])\n    price: float = df[\"close\"].iloc[-1]\n    return qty * price\n</code></pre>"},{"location":"reference/qoc/market/#qoc.market.Market.step","title":"step","text":"<pre><code>step(api: ApiBinance | ApiOffline) -&gt; None\n</code></pre> Source code in <code>src/qoc/market/_market.py</code> <pre><code>def step(self, api: api.ApiBinance|api.ApiOffline) -&gt; None:\n    for symbol in self.symbols:\n        klines: pl.DataFrame = api.klines(symbol, self.interval)\n        # ic(klines)\n\n        self.library.append(symbol, klines)\n</code></pre>"},{"location":"reference/qoc/market/#qoc.market.Market.tail","title":"tail","text":"<pre><code>tail(\n    symbol: str,\n    n: int = 5,\n    columns: Sequence[str] | None = None,\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/market/_market.py</code> <pre><code>def tail(\n    self, symbol: str, n: int = 5, columns: Sequence[str] | None = None\n) -&gt; pd.DataFrame:\n    return self.library.tail(symbol, n=n, columns=columns)\n</code></pre>"},{"location":"reference/qoc/strategy/","title":"qoc.strategy","text":""},{"location":"reference/qoc/strategy/#qoc.strategy","title":"qoc.strategy","text":"<p>Classes:</p> <ul> <li> <code>Strategy</code>           \u2013            </li> <li> <code>StrategySingleSymbol</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/strategy/#qoc.strategy.Strategy","title":"Strategy","text":"<p>               Bases: <code>ABC</code></p> <p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>dump</code>             \u2013              </li> <li> <code>step</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/strategy/#qoc.strategy.Strategy.library","title":"library  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library: Library = field(metadata={'dump': False})\n</code></pre>"},{"location":"reference/qoc/strategy/#qoc.strategy.Strategy.dump","title":"dump  <code>abstractmethod</code>","text":"<pre><code>dump(now: datetime) -&gt; None\n</code></pre> Source code in <code>src/qoc/strategy/_abc.py</code> <pre><code>@abc.abstractmethod\ndef dump(self, now: datetime.datetime) -&gt; None: ...\n</code></pre>"},{"location":"reference/qoc/strategy/#qoc.strategy.Strategy.step","title":"step  <code>abstractmethod</code>","text":"<pre><code>step(\n    api: ApiBinance, market: Market, now: datetime\n) -&gt; None\n</code></pre> Source code in <code>src/qoc/strategy/_abc.py</code> <pre><code>@abc.abstractmethod\ndef step(\n    self, api: api.ApiBinance, market: market.Market, now: datetime.datetime\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/qoc/strategy/#qoc.strategy.StrategySingleSymbol","title":"StrategySingleSymbol","text":"<p>               Bases: <code>Strategy</code></p> <p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>symbols</code>               (<code>list[str]</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>dump</code>             \u2013              </li> <li> <code>step</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>symbol</code>               (<code>str</code>)           \u2013            </li> <li> <code>symbols</code>               (<code>list[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/strategy/#qoc.strategy.StrategySingleSymbol.library","title":"library  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library: Library = field(metadata={'dump': False})\n</code></pre>"},{"location":"reference/qoc/strategy/#qoc.strategy.StrategySingleSymbol.symbol","title":"symbol  <code>property</code>","text":"<pre><code>symbol: str\n</code></pre>"},{"location":"reference/qoc/strategy/#qoc.strategy.StrategySingleSymbol.symbols","title":"symbols  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbols: list[str] = field(\n    factory=list, metadata={\"dump\": False}\n)\n</code></pre>"},{"location":"reference/qoc/strategy/#qoc.strategy.StrategySingleSymbol.dump","title":"dump","text":"<pre><code>dump(now: datetime) -&gt; None\n</code></pre> Source code in <code>src/qoc/strategy/_abc.py</code> <pre><code>@override\ndef dump(self, now: datetime.datetime) -&gt; None:\n    data: pl.DataFrame = pl.from_dicts(\n        [attrs.asdict(self, filter=self._dump_filter)]\n    )\n    data = data.insert_column(0, pl.Series(\"time\", [now]))\n\n    # Dump data for each symbol\n    for symbol in self.symbols:\n        self.library.append(symbol, data)\n</code></pre>"},{"location":"reference/qoc/strategy/#qoc.strategy.StrategySingleSymbol.step","title":"step  <code>abstractmethod</code>","text":"<pre><code>step(\n    api: ApiBinance, market: Market, now: datetime\n) -&gt; None\n</code></pre> Source code in <code>src/qoc/strategy/_abc.py</code> <pre><code>@abc.abstractmethod\ndef step(\n    self, api: api.ApiBinance, market: market.Market, now: datetime.datetime\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/qoc/struct/","title":"qoc.struct","text":""},{"location":"reference/qoc/struct/#qoc.struct","title":"qoc.struct","text":"<p>Modules:</p> <ul> <li> <code>typed</code>           \u2013            </li> </ul> <p>Type Aliases:</p> <ul> <li> <code>CoinName</code>           \u2013            </li> <li> <code>FeatureName</code>           \u2013            </li> <li> <code>Timestamp</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>State</code>           \u2013            </li> <li> <code>TimeFrame</code>           \u2013            </li> <li> <code>TimeIndex</code>           \u2013            </li> <li> <code>TimeSeries</code>           \u2013            </li> <li> <code>TimeUnit</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/struct/#qoc.struct.CoinName","title":"CoinName","text":"<pre><code>CoinName = str\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.FeatureName","title":"FeatureName","text":"<pre><code>FeatureName = str\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.Timestamp","title":"Timestamp","text":"<pre><code>Timestamp = int\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.State","title":"State","text":"<p>Parameters:</p> <ul> <li> <code>coins</code>               (<code>list[TypeAliasType]</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> </li> <li> <code>raw</code>               (<code>TimeFrame</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>trade</code>               (<code>TimeFrame</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>strategy</code>               (<code>TimeFrame</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>coins</code>               (<code>list[CoinName]</code>)           \u2013            </li> <li> <code>raw</code>               (<code>TimeFrame</code>)           \u2013            </li> <li> <code>strategy</code>               (<code>TimeFrame</code>)           \u2013            </li> <li> <code>trade</code>               (<code>TimeFrame</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/struct/#qoc.struct.State.coins","title":"coins  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>coins: list[CoinName] = field(factory=list)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.State.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: TimeFrame = field(factory=TimeFrame)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.State.strategy","title":"strategy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>strategy: TimeFrame = field(factory=TimeFrame)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.State.trade","title":"trade  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trade: TimeFrame = field(factory=TimeFrame)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeFrame","title":"TimeFrame","text":"<p>Parameters:</p> <ul> <li> <code>time_index</code>               (<code>TimeIndex</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> <li> <code>append</code>             \u2013              </li> <li> <code>to_numpy</code>             \u2013              </li> <li> <code>to_pandas</code>             \u2013              </li> <li> <code>to_polars</code>             \u2013              </li> <li> <code>to_torch</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>time_index</code>               (<code>TimeIndex</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/struct/#qoc.struct.TimeFrame.time_index","title":"time_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>time_index: TimeIndex = field(factory=TimeIndex)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeFrame.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: KT) -&gt; TimeSeries\n</code></pre> Source code in <code>src/qoc/struct/_time_frame.py</code> <pre><code>def __getitem__(self, index: KT) -&gt; TimeSeries:\n    return TimeSeries(\n        name=index, time_index=self.time_index, _data=self._data[index]\n    )\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeFrame.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/qoc/struct/_time_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self._data)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeFrame.append","title":"append","text":"<pre><code>append(value: dict[KT, VT], timestamp: Timestamp) -&gt; None\n</code></pre> Source code in <code>src/qoc/struct/_time_frame.py</code> <pre><code>def append(self, value: dict[KT, VT], timestamp: Timestamp) -&gt; None:\n    self.time_index.append(timestamp)\n    time_cnt: int = len(self.time_index)\n    idx: int = time_cnt - 1\n    for k in self._data:\n        self._data[k] += [None] * (time_cnt - len(self._data[k]))  # pyright: ignore[reportArgumentType]\n    for k, v in value.items():\n        if k not in self._data:\n            self._data[k] = [None] * time_cnt  # pyright: ignore[reportArgumentType]\n        self._data[k][idx] = v\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeFrame.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; Float[ndarray, 'n T']\n</code></pre> Source code in <code>src/qoc/struct/_time_frame.py</code> <pre><code>def to_numpy(self) -&gt; Float[np.ndarray, \"n T\"]:\n    return np.asarray(self._data.values())\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeFrame.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas() -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/struct/_time_frame.py</code> <pre><code>def to_pandas(self) -&gt; pd.DataFrame:\n    raise NotImplementedError  # TODO(liblaf)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeFrame.to_polars","title":"to_polars","text":"<pre><code>to_polars() -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/struct/_time_frame.py</code> <pre><code>def to_polars(self) -&gt; pl.DataFrame:\n    return pl.from_dict({\"timestamp\": self.time_index} | self._data)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeFrame.to_torch","title":"to_torch","text":"<pre><code>to_torch() -&gt; Float[Tensor, ' T']\n</code></pre> Source code in <code>src/qoc/struct/_time_frame.py</code> <pre><code>def to_torch(self) -&gt; Float[torch.Tensor, \" T\"]:\n    return torch.as_tensor(self._data)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeIndex","title":"TimeIndex","text":"<p>               Bases: <code>Sequence[Timestamp]</code></p> <p>Parameters:</p> <ul> <li> <code>unit</code>               (<code>TimeUnit</code>, default:                   <code>&lt;TimeUnit.SECOND: 's'&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> <li> <code>append</code>             \u2013              <p>Append a new timestamp to the timeline.</p> </li> <li> <code>to_numpy</code>             \u2013              </li> <li> <code>to_pandas</code>             \u2013              </li> <li> <code>to_polars</code>             \u2013              <p>Convert the timeline to a polars.DataFrame.</p> </li> <li> <code>to_torch</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>latest</code>               (<code>Timestamp</code>)           \u2013            <p>Get the latest timestamp in the timeline.</p> </li> <li> <code>unit</code>               (<code>TimeUnit</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/struct/#qoc.struct.TimeIndex.latest","title":"latest  <code>property</code>","text":"<pre><code>latest: Timestamp\n</code></pre> <p>Get the latest timestamp in the timeline.</p> <p>Returns:</p> <ul> <li> <code>Timestamp</code>           \u2013            <p>The most recent timestamp in the timeline, or -1 if the timeline is empty.</p> </li> </ul>"},{"location":"reference/qoc/struct/#qoc.struct.TimeIndex.unit","title":"unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit: TimeUnit = SECOND\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeIndex.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; Timestamp\n</code></pre><pre><code>__getitem__(index: slice) -&gt; Self\n</code></pre> <pre><code>__getitem__(index: int | slice) -&gt; Timestamp | Self\n</code></pre> Source code in <code>src/qoc/struct/_time_index.py</code> <pre><code>def __getitem__(self, index: int | slice) -&gt; Timestamp | Self:\n    if isinstance(index, int):\n        return self._timestamp[index]\n    if isinstance(index, slice):\n        return attrs.evolve(self, _timestamp=self._timestamp[index])\n    assert_never()\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeIndex.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/qoc/struct/_time_index.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self._timestamp)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeIndex.append","title":"append","text":"<pre><code>append(timestamp: Timestamp) -&gt; None\n</code></pre> <p>Append a new timestamp to the timeline.</p> <p>Parameters:</p> <ul> <li> <code>timestamp</code>               (<code>Timestamp</code>)           \u2013            <p>The timestamp to append to the timeline.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If timestamp is earlier than the latest timestamp (only in debug mode).</p> </li> </ul> Note <p>If the timestamp is equal to or earlier than the latest timestamp, the method returns without appending anything.</p> Source code in <code>src/qoc/struct/_time_index.py</code> <pre><code>def append(self, timestamp: Timestamp) -&gt; None:\n    \"\"\"Append a new timestamp to the timeline.\n\n    Args:\n        timestamp: The timestamp to append to the timeline.\n\n    Raises:\n        ValueError: If timestamp is earlier than the latest timestamp (only in debug mode).\n\n    Note:\n        If the timestamp is equal to or earlier than the latest timestamp,\n        the method returns without appending anything.\n    \"\"\"\n    if __debug__ and timestamp &lt; self.latest:\n        msg: str = f\"Timestamp {timestamp} is earlier than the latest timestamp {self.latest}.\"\n        raise ValueError(msg)\n    if timestamp &lt;= self.latest:\n        return\n    self._timestamp.append(timestamp)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeIndex.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; UInt64[ndarray, ' T']\n</code></pre> Source code in <code>src/qoc/struct/_time_index.py</code> <pre><code>def to_numpy(self) -&gt; UInt64[np.ndarray, \" T\"]:\n    return np.asarray(self._timestamp, dtype=np.uint64)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeIndex.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas() -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/struct/_time_index.py</code> <pre><code>def to_pandas(self) -&gt; pd.DataFrame:\n    raise NotImplementedError  # TODO(liblaf)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeIndex.to_polars","title":"to_polars","text":"<pre><code>to_polars() -&gt; DataFrame\n</code></pre> <p>Convert the timeline to a polars.DataFrame.</p> <p>Returns:</p> <ul> <li> <code>timestamp</code> (              <code>UInt64</code> )          \u2013            <p>Timestamps in corresponding time unit.</p> </li> </ul> Source code in <code>src/qoc/struct/_time_index.py</code> <pre><code>def to_polars(self) -&gt; pl.DataFrame:\n    \"\"\"Convert the timeline to a polars.DataFrame.\n\n    Returns:\n        timestamp (pl.UInt64): Timestamps in corresponding time unit.\n    \"\"\"\n    return pl.DataFrame(\n        {\"timestamp\": self._timestamp}, schema_overrides={\"timestamp\": pl.UInt64}\n    )\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeIndex.to_torch","title":"to_torch","text":"<pre><code>to_torch() -&gt; UInt64[Tensor, ' T']\n</code></pre> Source code in <code>src/qoc/struct/_time_index.py</code> <pre><code>def to_torch(self) -&gt; UInt64[torch.Tensor, \" T\"]:\n    return torch.as_tensor(self._timestamp, dtype=torch.uint64)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeSeries","title":"TimeSeries","text":"<p>               Bases: <code>Sequence[T]</code></p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | Sequence[str]</code>, default:                   <code>'value'</code> )           \u2013            </li> <li> <code>time_index</code>               (<code>TimeIndex</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> <li> <code>append</code>             \u2013              <p>Append a new value with its corresponding timestamp to the time series.</p> </li> <li> <code>to_numpy</code>             \u2013              </li> <li> <code>to_pandas</code>             \u2013              </li> <li> <code>to_polars</code>             \u2013              <p>Converts the time series to a Polars DataFrame.</p> </li> <li> <code>to_torch</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>latest</code>               (<code>T</code>)           \u2013            </li> <li> <code>name</code>               (<code>str | Sequence[str]</code>)           \u2013            </li> <li> <code>time_index</code>               (<code>TimeIndex</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/struct/#qoc.struct.TimeSeries.latest","title":"latest  <code>property</code>","text":"<pre><code>latest: T\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeSeries.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | Sequence[str] = field(default='value')\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeSeries.time_index","title":"time_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>time_index: TimeIndex = field(factory=TimeIndex)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeSeries.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; T\n</code></pre><pre><code>__getitem__(index: slice) -&gt; Self\n</code></pre> <pre><code>__getitem__(index: int | slice) -&gt; T | Self\n</code></pre> Source code in <code>src/qoc/struct/_time_series.py</code> <pre><code>def __getitem__(self, index: int | slice) -&gt; T | Self:\n    if isinstance(index, int):\n        return self._data[index]\n    if isinstance(index, slice):\n        return attrs.evolve(self, _data=self._data[index])\n    assert_never()\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeSeries.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/qoc/struct/_time_series.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self._data)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeSeries.append","title":"append","text":"<pre><code>append(value: T, timestamp: Timestamp) -&gt; None\n</code></pre> <p>Append a new value with its corresponding timestamp to the time series.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>T</code>)           \u2013            <p>The value to append to the time series data.</p> </li> <li> <code>timestamp</code>               (<code>Timestamp</code>)           \u2013            <p>The timestamp associated with the value.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>In debug mode, if the timeline and data lengths become inconsistent.</p> </li> </ul> Note <p>This method maintains the invariant that the timeline and data arrays have the same length.</p> Source code in <code>src/qoc/struct/_time_series.py</code> <pre><code>def append(self, value: T, timestamp: Timestamp) -&gt; None:\n    \"\"\"Append a new value with its corresponding timestamp to the time series.\n\n    Args:\n        value: The value to append to the time series data.\n        timestamp: The timestamp associated with the value.\n\n    Raises:\n        AssertionError: In debug mode, if the timeline and data lengths become inconsistent.\n\n    Note:\n        This method maintains the invariant that the timeline and data arrays have the same length.\n    \"\"\"\n    self.time_index.append(timestamp)\n    self._data.append(value)\n    if __debug__:\n        assert len(self.time_index) == len(self)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeSeries.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; Float[ndarray, ' T']\n</code></pre> Source code in <code>src/qoc/struct/_time_series.py</code> <pre><code>def to_numpy(self) -&gt; Float[np.ndarray, \" T\"]:\n    return np.asarray(self._data)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeSeries.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas() -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/struct/_time_series.py</code> <pre><code>def to_pandas(self) -&gt; pd.DataFrame:\n    raise NotImplementedError  # TODO(liblaf)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeSeries.to_polars","title":"to_polars","text":"<pre><code>to_polars() -&gt; DataFrame\n</code></pre> <p>Converts the time series to a Polars DataFrame.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame with two columns:</p> <ul> <li>timestamp (pl.UInt64): Containing the timeline of the series.</li> <li>self.name (T): Containing the data of the series.</li> </ul> </li> </ul> Source code in <code>src/qoc/struct/_time_series.py</code> <pre><code>def to_polars(self) -&gt; pl.DataFrame:\n    \"\"\"Converts the time series to a Polars DataFrame.\n\n    Returns:\n        A DataFrame with two columns:\n\n            - timestamp (pl.UInt64): Containing the timeline of the series.\n            - self.name (T): Containing the data of the series.\n    \"\"\"\n    return pl.from_dict({\"timestamp\": self.time_index, self.name: self._data})\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeSeries.to_torch","title":"to_torch","text":"<pre><code>to_torch() -&gt; Float[Tensor, ' T']\n</code></pre> Source code in <code>src/qoc/struct/_time_series.py</code> <pre><code>def to_torch(self) -&gt; Float[torch.Tensor, \" T\"]:\n    return torch.as_tensor(self._data)\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeUnit","title":"TimeUnit","text":"<p>               Bases: <code>StrEnum</code></p> <p>Attributes:</p> <ul> <li> <code>MICROSECOND</code>           \u2013            </li> <li> <code>MILLISECOND</code>           \u2013            </li> <li> <code>MINUTE</code>           \u2013            </li> <li> <code>NANOSECOND</code>           \u2013            </li> <li> <code>SECOND</code>           \u2013            </li> <li> <code>seconds</code>               (<code>float</code>)           \u2013            </li> </ul>"},{"location":"reference/qoc/struct/#qoc.struct.TimeUnit.MICROSECOND","title":"MICROSECOND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MICROSECOND = 'us'\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeUnit.MILLISECOND","title":"MILLISECOND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MILLISECOND = 'ms'\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeUnit.MINUTE","title":"MINUTE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTE = 'min'\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeUnit.NANOSECOND","title":"NANOSECOND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NANOSECOND = 'ns'\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeUnit.SECOND","title":"SECOND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SECOND = 's'\n</code></pre>"},{"location":"reference/qoc/struct/#qoc.struct.TimeUnit.seconds","title":"seconds  <code>property</code>","text":"<pre><code>seconds: float\n</code></pre>"},{"location":"reference/qoc/struct/typed/","title":"qoc.struct.typed","text":""},{"location":"reference/qoc/struct/typed/#qoc.struct.typed","title":"qoc.struct.typed","text":"<p>Type Aliases:</p> <ul> <li> <code>CoinName</code>           \u2013            </li> <li> <code>FeatureName</code>           \u2013            </li> <li> <code>Timestamp</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/struct/typed/#qoc.struct.typed.CoinName","title":"CoinName","text":"<pre><code>CoinName = str\n</code></pre>"},{"location":"reference/qoc/struct/typed/#qoc.struct.typed.FeatureName","title":"FeatureName","text":"<pre><code>FeatureName = str\n</code></pre>"},{"location":"reference/qoc/struct/typed/#qoc.struct.typed.Timestamp","title":"Timestamp","text":"<pre><code>Timestamp = int\n</code></pre>"},{"location":"reference/qoc/utils/","title":"qoc.utils","text":""},{"location":"reference/qoc/utils/#qoc.utils","title":"qoc.utils","text":"<p>Type Aliases:</p> <ul> <li> <code>SnapLike</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>CaseInsensitiveEnum</code>           \u2013            </li> <li> <code>Snap</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>clock</code>             \u2013              </li> <li> <code>data_dir</code>             \u2013              </li> <li> <code>entrypoint</code>             \u2013              </li> <li> <code>fig_dir</code>             \u2013              </li> <li> <code>get_args</code>             \u2013              </li> <li> <code>get_logger</code>             \u2013              </li> <li> <code>insert_time</code>             \u2013              </li> <li> <code>working_dir</code>             \u2013              </li> </ul>"},{"location":"reference/qoc/utils/#qoc.utils.SnapLike","title":"SnapLike","text":"<pre><code>SnapLike = Snap | Literal['none', 'second']\n</code></pre>"},{"location":"reference/qoc/utils/#qoc.utils.CaseInsensitiveEnum","title":"CaseInsensitiveEnum","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"reference/qoc/utils/#qoc.utils.Snap","title":"Snap","text":"<p>               Bases: <code>StrEnum</code></p> <p>Methods:</p> <ul> <li> <code>ceil</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>NONE</code>           \u2013            </li> <li> <code>SECOND</code>           \u2013            </li> </ul>"},{"location":"reference/qoc/utils/#qoc.utils.Snap.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = auto()\n</code></pre>"},{"location":"reference/qoc/utils/#qoc.utils.Snap.SECOND","title":"SECOND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SECOND = auto()\n</code></pre>"},{"location":"reference/qoc/utils/#qoc.utils.Snap.ceil","title":"ceil","text":"<pre><code>ceil(time: datetime) -&gt; datetime\n</code></pre> Source code in <code>src/qoc/utils/_clock.py</code> <pre><code>def ceil(self, time: datetime.datetime) -&gt; datetime.datetime:\n    match self:\n        case Snap.NONE:\n            return time\n        case Snap.SECOND:\n            if time.microsecond &gt; 0:\n                time += datetime.timedelta(seconds=1)\n            return time.replace(microsecond=0)\n        case v:\n            raise grapes.error.MatchError(v)\n</code></pre>"},{"location":"reference/qoc/utils/#qoc.utils.clock","title":"clock","text":"<pre><code>clock(\n    interval: timedelta = timedelta(seconds=1),\n    *,\n    end: datetime | None = None,\n    max_duration: timedelta | None = None,\n    max_iter: int | None = None,\n    offline: bool = False,\n    snap: SnapLike = NONE,\n    start: datetime | None = None,\n) -&gt; Generator[datetime]\n</code></pre> Source code in <code>src/qoc/utils/_clock.py</code> <pre><code>def clock(\n    interval: datetime.timedelta = datetime.timedelta(seconds=1),\n    *,\n    end: datetime.datetime | None = None,\n    max_duration: datetime.timedelta | None = None,\n    max_iter: int | None = None,\n    offline: bool = False,\n    snap: SnapLike = Snap.NONE,\n    start: datetime.datetime | None = None,\n) -&gt; Generator[datetime.datetime]:\n    snap = Snap(snap)\n    if start is None:\n        start = datetime.datetime.now(tz=datetime.UTC)\n    start = snap.ceil(start)\n    if max_duration is not None:\n        # Ensure the clock does not exceed either the specified 'end' time or the maximum duration.\n        if end is not None:\n            end = min(end, start + max_duration)\n        else:\n            end = start + max_duration\n    for tick in _ticks(interval, end=end, max_iter=max_iter, start=start):\n        if offline:\n            yield tick\n            continue\n        now: datetime.datetime = datetime.datetime.now(tz=datetime.UTC)\n        sleep_for: float = (tick - now).total_seconds()\n        if sleep_for &lt;= 0:\n            logger.warning(\n                \"clock tick is behind schedule (negative sleep): {} &lt; {}\",\n                tick.isoformat(),\n                now.isoformat(),\n            )\n            continue\n        time.sleep(sleep_for)\n        logger.debug(\"clock tick: {}\", tick.isoformat())\n        yield tick\n</code></pre>"},{"location":"reference/qoc/utils/#qoc.utils.data_dir","title":"data_dir","text":"<pre><code>data_dir(path: str | PathLike[str] = '.') -&gt; Path\n</code></pre> Source code in <code>src/qoc/utils/_path.py</code> <pre><code>def data_dir(path: str | os.PathLike[str] = \".\") -&gt; Path:\n    path = Path(path)\n    if path.is_absolute():\n        return path\n    return working_dir() / \"data\" / path\n</code></pre>"},{"location":"reference/qoc/utils/#qoc.utils.entrypoint","title":"entrypoint","text":"<pre><code>entrypoint() -&gt; Path\n</code></pre> Source code in <code>src/qoc/utils/_path.py</code> <pre><code>def entrypoint() -&gt; Path:\n    return Path(sys.argv[0]).absolute()\n</code></pre>"},{"location":"reference/qoc/utils/#qoc.utils.fig_dir","title":"fig_dir","text":"<pre><code>fig_dir(path: str | PathLike[str] = '.') -&gt; Path\n</code></pre> Source code in <code>src/qoc/utils/_path.py</code> <pre><code>def fig_dir(path: str | os.PathLike[str] = \".\") -&gt; Path:\n    path = Path(path)\n    if path.is_absolute():\n        return path\n    return working_dir() / \"fig\" / path\n</code></pre>"},{"location":"reference/qoc/utils/#qoc.utils.get_args","title":"get_args","text":"<pre><code>get_args()\n</code></pre> Source code in <code>src/qoc/utils/_parse.py</code> <pre><code>def get_args():\n    parser = argparse.ArgumentParser(description=\"Run with YAML config\")\n    parser.add_argument(\n        \"--conf_path\",\n        type=str,\n        default=\"config/example.yaml\",\n        help=\"Path to the YAML configuration file\",\n    )\n    args = parser.parse_args()\n    return args\n</code></pre>"},{"location":"reference/qoc/utils/#qoc.utils.get_logger","title":"get_logger","text":"<pre><code>get_logger(config)\n</code></pre> Source code in <code>src/qoc/utils/_logger.py</code> <pre><code>def get_logger(config):\n    # \u8bbe\u7f6e\u65e5\u5fd7\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        handlers=[\n            logging.FileHandler(f\"{config['output_path']}/log.txt\"),\n            logging.StreamHandler(),\n        ],\n    )\n    logger = logging.getLogger(__name__)\n    return logger\n</code></pre>"},{"location":"reference/qoc/utils/#qoc.utils.insert_time","title":"insert_time","text":"<pre><code>insert_time(\n    df: DataFrame, time: datetime, column_name: str = \"time\"\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/qoc/utils/_polars.py</code> <pre><code>def insert_time(\n    df: pl.DataFrame, time: datetime.datetime, column_name: str = \"time\"\n) -&gt; pl.DataFrame:\n    if isinstance(time, datetime.datetime):\n        time_value = int(time.timestamp() * 1000000)  # \u8f6c\u6362\u4e3a\u5fae\u79d2\u65f6\u95f4\u6233\n\n    return df.insert_column(0, pl.Series(column_name, [time_value]))\n</code></pre>"},{"location":"reference/qoc/utils/#qoc.utils.working_dir","title":"working_dir","text":"<pre><code>working_dir(path: str | PathLike[str] = '.') -&gt; Path\n</code></pre> Source code in <code>src/qoc/utils/_path.py</code> <pre><code>def working_dir(path: str | os.PathLike[str] = \".\") -&gt; Path:\n    path = Path(path)\n    if path.is_absolute():\n        return path\n    return entrypoint().parent / path\n</code></pre>"}]}